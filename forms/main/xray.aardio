import debug;
import debug.log;
import console;

import win.ui;
import fonts.fontAwesome;
//namespace xray
/*DSG{{*/
var frmXray = win.form(text="WinXray ";right=959;bottom=591;bgcolor=16777215)
frmXray.add(
btnChangeServer={cls="plus";text="手动换服";left=872;top=366;right=945;bottom=398;align="left";bgcolor=11580047;border={radius=4};db=1;dr=1;font=LOGFONT(h=-13);notify=1;textPadding={left=6};z=10};
btnEditPacOrUwp={cls="plus";text="编辑PAC";left=308;top=361;right=414;bottom=376;align="left";db=1;dr=1;font=LOGFONT(h=-13);iconStyle={align="left";font=LOGFONT(h=-13;name='FontAwesome');padding={left=12}};iconText='\uF1C4';notify=1;textPadding={left=30};z=7};
btnImportServerFromClipBd={cls="plus";text="批量导入链接";left=308;top=382;right=441;bottom=399;align="left";db=1;dr=1;font=LOGFONT(h=-13);iconStyle={align="left";font=LOGFONT(h=-13;name='FontAwesome');padding={left=12}};iconText='\uF196 ';notify=1;textPadding={left=30};z=8};
btnTcping={cls="plus";text="检测并连接最快服务器";left=674;top=366;right=868;bottom=398;align="left";bgcolor=11580047;border={radius=4};db=1;dr=1;font=LOGFONT(h=-13);iconStyle={align="left";font=LOGFONT(h=-13;name='FontAwesome');padding={left=18}};iconText='\uF012';notify=1;textPadding={left=42};z=3};
chkAutoTest={cls="plus";text="异常自动重连 ";left=432;top=387;right=557;bottom=401;align="left";db=1;dr=1;font=LOGFONT(h=-13);iconStyle={align="left";font=LOGFONT(h=-13;name='FontAwesome');padding={left=12}};iconText='\uF0C8';notify=1;textPadding={left=30};z=9};
chkJustValid={cls="checkbox";text="仅连接已测通";left=434;top=381;right=527;bottom=395;z=13};
chkSearchMode={cls="checkbox";text="开启后台搜索";left=548;top=380;right=643;bottom=394;z=11};
chkValidNoSearch={cls="checkbox";text="已测通不搜索";left=547;top=402;right=644;bottom=416;z=12};
edit={cls="edit";left=7;top=404;right=954;bottom=584;autohscroll=false;bgcolor=0;color=16777215;db=1;dl=1;dr=1;edge=1;multiline=1;vscroll=1;z=2};
listview={cls="listview";left=4;top=5;right=954;bottom=358;db=1;dl=1;dr=1;dt=1;edge=1;fullRow=1;gridLines=1;z=1};
radioProxy={cls="radiobutton";text="全局代理";left=115;top=367;right=194;bottom=397;bgcolor=16777215;db=1;dl=1;font=LOGFONT(h=-13);z=4};
radioProxyDirect={cls="radiobutton";text="不使用代理";left=8;top=367;right=108;bottom=397;bgcolor=16777215;db=1;dl=1;font=LOGFONT(h=-13);z=6};
radioProxyPac={cls="radiobutton";text="PAC代理";left=206;top=367;right=280;bottom=397;bgcolor=16777215;db=1;dl=1;font=LOGFONT(h=-13);z=5}
)
/*}}*/

//插入要显示的列
frmXray.listview.insertColumn("类型",50) 
frmXray.listview.insertColumn("服务器",120) 
frmXray.listview.insertColumn("端口",45) 
frmXray.listview.insertColumn("加密",50) 
frmXray.listview.insertColumn("协议",40) 
frmXray.listview.insertColumn("备注",50) 
frmXray.listview.insertColumn("响应速度（ms）",50) 
frmXray.listview.insertColumn("状态",175);
frmXray.listview.insertColumn("上传流量",60) 
frmXray.listview.insertColumn("下载流量",60) 
frmXray.listview.insertColumn("上传速度（最高）",60) 
frmXray.listview.insertColumn("下载速度（最高）",-1) 

// 减少闪烁，详见：https://learn.microsoft.com/zh-cn/windows/win32/controls/extended-list-view-styles
frmXray.listview.setExtended(0x10000/*_LVS_EX_DOUBLEBUFFER*/);

frmXray.show();//显示窗口

//检测服务器是否可代理
//import config;
import xray.core; 
var currentOutboundIndex,currentOutboundAddress;//全局记录当前正在代理的服务器
var isManualSwitch=false;//记录当前是否手动触发导致服务器切换
var isOnSearching = false;//正在搜索可用服务器标志,用来标志当前服务器是可用的，本次onXrayFail为搜索成功后自动跳转，传过来的服务器不要标志为不可用
var waitCount=0;//等待可用列表次数
var trafficTimerId;//流量定时器
var testTimerId;//检测定时器
var autoTestTime ;//记录定时检测的时间间隔
frmXray.searcherIndex =0 ; //正在搜索的序列号
frmXray.searchingBackground = false;
frmXray.isOnActive = false;//正在运行一个检测标志，当为1时等待其结束
var saveTimerId = frmXray.setInterval( 600000,function(){//定时保存proxy数据
		//debug.log.print("proxy save")
		config.proxy.save()	
	}
);
//debug.log.print(saveTimerId);


//测试服务器是否可用
var started;
/*************
var activeOutbound
	activeOutbound = function(outboundIndex,outboundAddress,enableRetry,timerTesting){//定时检测标志,否则说明是新服务器,要重启内核
	//for (i=1;120;1){
		debug.log.print("activeOutbound被运行")
		if(frmXray.isOnActive) {
			debug.log.print("frmXray.isOnActive=1")
			currentOutboundIndex,currentOutboundAddress = outboundIndex,outboundAddress;
			if(testTimerId){
				frmXray.clearInterval(testTimerId);	//删除定时器
			}	
			testTimerId = frmXray.setInterval( config.proxy.testInterval*1000,function(){
					if(frmXray.btnTcping.disabled) return;//正在寻找服务器就返回
					if( frmXray.autoTesting ) return; //如果是自动测试就退出
					activeOutbound(outboundIndex,outboundAddress,true,false);//定时检测代理状态
				})		
			return ; 	
			
		}
		else {
			frmXray.isOnActive=1;
			//break;
		}
		
	//}
	//debug.log.print("开始检测");
	// 如果没有值，则取得值并返回（但currentOutboundIndex刚启动也没有值）
	if(!outboundIndex && !outboundAddress){//传过来的当前服务器参数如果为空,使用全局服务器
		outboundIndex,outboundAddress = currentOutboundIndex,currentOutboundAddress;
		if(!outboundIndex && !outboundAddress) {//如果全局服务器为空,则返回
			return;
		}
	}
	
	import debug
	//debug.debug();
/*
	if(enableRetry) {console.log("activeOutbound重试标志为：true")}
	else {
	console.log("activeOutbound重试标志为：false")
	}
*/
	
	
	// 如果配置文件中没有对应序号服务器，那么就返回
	var outbound = config.proxy.outbounds[outboundIndex];
	if(!outbound){
		return ; 
	} 
	frmXray.listview.ensureVisible(outboundIndex);//确保此行可见
 	if(!timerTesting) {frmXray.listview.setItemText("测试中",outboundIndex,8);}
 	// 按"检测并连接最快服务器"按钮之后，传进来的是空，所以会进入下面的判断
	var startTesting = timerTesting;//是否是定时器连通测试
	if(!startTesting){
		..publish("activeOutbound",false); //不是定时检测，发布“检测服务器失败,正在使用的地址置为false”
		//console.dump(xray.core.prcsxray);
		//debug.log.print(xray.core.prcsxray);
		//var started
		//console.dump(outbound);
		if(!xray.core.prcsxray || outbound.protocol == "ssr" || outbound.protocol == "naive" ){
			started,err = xray.core.restart(frmXray.edit,outbound);//重启内核
			startTesting = started;
			/*
console.dump(xray.core.prcsxray);
		debug.log.print(xray.core.prcsxray);
			debug.log.print(started);
*/
		}
		else {
			started = xray.core.prcsxray ? true : false;
			import sysProxy;
			// reset，不使用代理
			..sysProxy.reset(false);
			startTesting = started;
			var cleaner;
			var i=1;			
			while(!cleaner && i<4){
				i++;
				//console.print("删除配置回复null")	
				//cleaner = xray.core.stopSearcher(frmXray.edit,outbound);
				cleaner = xray.core.deleteOutbound(frmXray.edit,outbound,"proxy");
				debug.debug();				
				//sleep(500);
			}
			//debug.log.print("cleaner:"+cleaner)	
			
			var adder//xray添加搜索配置		
			while(!adder && i>1){
				//console.print("添加配置回复null")
				//adder = xray.core.startSearcher(frmXray.edit,next);
				i--;
				adder = xray.core.addOutbound(frmXray,frmXray.edit,outbound,"proxy","proxyConfig.json");				
				//sleep(5000);
			}
			 if(!cleaner || !adder ) {
			 	started,err = xray.core.restart(frmXray.edit,outbound);//重启内核
				startTesting = started;
			 }
			 else {
			 	..publish("xrayCore.restarted",socksProxyPort,httpProxPort); 
			 }
			 
			//debug.log.print("adder:"+adder)	;
			//debug.debug();
		}
		
		
		//debug.log.print(started);
		//debug.debug();
		
		
				
		
		
		
		
		
		//var started,err = xray.core.restart(frmXray.edit,outbound);//重启内核
		//startTesting = started;
		
		if(!started){//如果失败就返回，成功就继续往后运行
			frmXray.edit.print("启动 Xray 错误",err:""); 
			frmXray.btnTcping.disabledText = null;
			return false;
		}
	}
	//if(frmXray.chkSearchMode.checked) frmXray.chkSearchMode.oncommand();//开始搜索
	currentOutboundIndex,currentOutboundAddress = outboundIndex,outboundAddress;
	if( startTesting  ){//是定时检测发起，则联网检测
		//currentOutboundIndex,currentOutboundAddress = outboundIndex,outboundAddress;
		frmXray.autoTesting = true;
		
		..thread.invoke( //新建测试线程
			function(frmXray,outboundIndex,outboundAddress,sockProxyPort,httpProxyAddress,enableRetry,timerTesting){
				import debug.log
				import console
				import config
				
				import web.rest.client;
				
				//debug.log.print("httpProxyAddress为："+httpProxyAddress);
				for(i=1;3;1){					
					var restClient = web.rest.client(,httpProxyAddress);
					restClient._http.setTimeouts(2000,9000,9000);
					timeTick = time.tick(); 
					var ret = restClient.get("https://www.google.com/generate_204");
					timeTick=time.tick() - timeTick; 
					//console.dump(config.proxy.outbounds[outboundIndex]);
					//if(!config.proxy.outbounds[outboundIndex].replyDelay ) 	config.proxy.outbounds[outboundIndex].replyDelay = 1000;					
					try{
					config.proxy.outbounds[outboundIndex].replyDelay = (config.proxy.outbounds[outboundIndex].replyDelay * 99 + timeTick )/100;
					//debug.log.print("响应时间为："+timeTick+"毫秒,平均时间为："+config.proxy.outbounds[outboundIndex].replyDelay+"毫秒");
					}
					
					
					var lastStatusCode = restClient.lastStatusCode;
					
					debug.log.print("活动检测器：回复为：",lastStatusCode,"timerTesting为：",timerTesting);
					if( lastStatusCode == 204 ){//连通，发布“连接成功”消息
						
						frmXray.isOnActive=0;
						frmXray.onStartXrayComplete(outboundIndex,outboundAddress,timerTesting); 
						
						//debug.debug();
						return;	
					}
					restClient.close();
				}
				
/*
				if(timerTesting){
					sleep(100);
				}
*/

				//测试socks5是否连通
/************
				import wsock.tcp.socks5Client;
				
				var client;
				for(i=1;2;1){
					sleep(200);
					client = wsock.tcp.socks5Client("127.0.0.1",sockProxyPort); 
					if(client)break;
				}
				
				if(client){
					client.setTimeouts(1000,1000); 
					if(client.connect("www.google.com",80) ){
						
						var sendData =/***********
GET /  HTTP/1.1
Host: www.google.com
Connection: close
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64)
Accept: */*;  
Accept-Language: zh-CN,zh; 
Accept-Charset:utf-8;  
***********/
						client.write( sendData + '\r\n\r\n' )
						var rep = client.read(9);
						client.close();
							console.dump(rep);
						if( rep && ..string.startWith(rep,"HTTP/1.1 ") ){							
							frmXray.onStartXrayComplete(outboundIndex,outboundAddress,timerTesting);
							return;	
						} 
					}
				};
************/
				//检测异常，调用异常继续寻找函数
				
			/*
		if(enableRetry) {debug.log.print("activeOutbound重试标志为：true")}
	else {	debug.log.print("activeOutbound重试标志为：false")
	}
*/
				frmXray.isOnActive=0;
				frmXray.onStartXrayFailed(outboundIndex,outboundAddress,enableRetry);
			},frmXray,outboundIndex,outboundAddress, 
			xray.core.socksProxyPort,xray.core.getSystemProxyConfig(),enableRetry,timerTesting
		)
	
		return true;
	}	
	//debug.log.print("frmXray.isOnActive = 0")
	//frmXray.isOnActive = 0;
}
*************/

switchOutbound = function(outboundIndex,outboundAddress){//定时检测标志,否则说明是新服务器,要重启内核
	
	if(!outboundIndex || !outboundAddress) {//如果服务器为空,则返回
		return;
	}	
	
	import debug
	//debug.debug();	
	
	// 如果配置文件中没有对应序号服务器，那么就返回
	var outbound = config.proxy.outbounds[outboundIndex];
	if(!outbound || outbound.address != outboundAddress){
		publish("uiCommand.restartxrayCore");
		return ; 
	} 
	if(trafficTimerId){ frmXray.clearInterval(trafficTimerId); }
	..publish("activeOutbound",false); //发布活动地址失效
		//console.dump(xray.core.prcsxray);
		//debug.log.print(xray.core.prcsxray);
		//var started
		//console.dump(outbound);
	currentOutboundIndex,currentOutboundAddress = outboundIndex,outboundAddress;
	
	var started;
	if(!xray.core.prcsxray || outbound.protocol == "ssr" || outbound.protocol == "naive"  ){
		started = xray.core.restart(frmXray.edit,outbound);//重启内核
		//debug.log.print("内核重启")
		
	/*
		console.dump(xray.core.prcsxray);
		debug.log.print(xray.core.prcsxray);
			debug.log.print(started);
*/
	}
		else {
			started = xray.core.prcsxray ? true : false;
			import sysProxy;
			// reset，不使用代理
			//..sysProxy.reset(false);
			var cleaner;
			var i=1;			
			while(!cleaner && i<4){
				i++;
				//console.print("删除配置回复null")	
				//cleaner = xray.core.stopSearcher(frmXray.edit,outbound);
				cleaner = xray.core.deleteOutbound(frmXray.edit,outbound,"proxy","proxyConfig.json");
				//debug.debug();				
				
			}
			//debug.log.print("cleaner:"+cleaner)	
			
			var adder//xray添加搜索配置		
			while(!adder && i>1){
				//console.print("添加配置回复null")
				//adder = xray.core.startSearcher(frmXray.edit,next);
				i--;
				adder = xray.core.addOutbound(frmXray,frmXray.edit,outbound,"proxy","proxyConfig.json");				
				//debug.log.print(adder);
			}
			 if(!cleaner || !adder ) {
			 	started = xray.core.restart(frmXray.edit,outbound);//重启内核
			 }
			 else {
			 	..publish("xrayCore.restarted",socksProxyPort,httpProxPort); 
			 }
			 
			//debug.log.print("adder:"+adder)	;
			//debug.debug();
		}
		
		//debug.log.print(started);
		//debug.debug();
		
		//var started,err = xray.core.restart(frmXray.edit,outbound);//重启内核
		//startTesting = started;
		
		if(!started){//如果失败就返回，成功就继续往后运行
			frmXray.edit.print("启动 Xray 错误",err:""); 
			frmXray.btnTcping.disabledText = null;
			return false;
		}

	testOutbound(outboundIndex,outboundAddress,frmXray.chkAutoTest.checked,false);
	//debug.log.print("frmXray.isOnActive = 0")
	//frmXray.isOnActive = 0;
}

testOutbound = function(outboundIndex,outboundAddress,enableRetry,timerTesting){//定时检测标志,否则说明是新服务器,要重启内核

	if(!outboundIndex || !outboundAddress) {//如果服务器为空,则返回
		return;
	}	
	if(outboundAddress == frmXray.listview.getItemText(outboundIndex,2) ) frmXray.listview.setItemText("测试中...",outboundIndex,8);
	frmXray.listview.ensureVisible(outboundIndex);//确保此行可见
	import debug
	//debug.debug();
	
		
		..thread.invoke( //新建测试线程
			function(frmXray,outboundIndex,outboundAddress,sockProxyPort,httpProxyAddress,enableRetry,timerTesting,outbounds){
				import debug.log
				import console
				//import config
				
				import web.rest.client;
				
				//debug.log.print("httpProxyAddress为："+sockProxyPort);
				var lastStatusCode ;
				for(i=1;2;1){					
					var restClient = web.rest.client(,httpProxyAddress);
					restClient._http.setTimeouts(4000,5000,5000);
					timeTick = time.tick(); 
					var ret = restClient.get("https://www.google.com/generate_204");
					timeTick=time.tick() - timeTick; 
					//console.dump(config.proxy.outbounds[outboundIndex]);
					//if(!config.proxy.outbounds[outboundIndex].replyDelay ) 	config.proxy.outbounds[outboundIndex].replyDelay = 1000;					
					try{
						//debug.log.print(#config.proxy.outbounds);
						outbounds[outboundIndex].replyDelay = (outbounds[outboundIndex].replyDelay * 99 + timeTick )/100;
					//debug.log.print("响应时间为："+timeTick+"毫秒,平均时间为："+config.proxy.outbounds[outboundIndex].replyDelay+"毫秒");
					}
					
					
					lastStatusCode = restClient.lastStatusCode;
					
					//debug.log.print("序号:"+outboundIndex+" 活动检测器：",lastStatusCode,",timerTesting为：",timerTesting,",地址"+outboundAddress);	
					restClient.close();
					
					
					if( lastStatusCode || lastStatusCode == 204 ) {

						frmXray.onStartXrayComplete(outboundIndex,outboundAddress,timerTesting); 
														
						//debug.debug();
						return ; 
						break;
					}										
				}
				
				
/*
				if(timerTesting){
					sleep(100);
				}
*/

				//测试socks5是否连通
/************
				import wsock.tcp.socks5Client;
				
				var client;
				for(i=1;2;1){
					sleep(200);
					client = wsock.tcp.socks5Client("127.0.0.1",sockProxyPort); 
					if(client)break;
				}
				
				if(client){
					client.setTimeouts(1000,1000); 
					if(client.connect("www.google.com",80) ){
						
						var sendData =/***********
GET /  HTTP/1.1
Host: www.google.com
Connection: close
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64)
Accept: */*;  
Accept-Language: zh-CN,zh; 
Accept-Charset:utf-8;  
***********/
						client.write( sendData + '\r\n\r\n' )
						var rep = client.read(9);
						client.close();
							console.dump(rep);
						if( rep && ..string.startWith(rep,"HTTP/1.1 ") ){							
							frmXray.onStartXrayComplete(outboundIndex,outboundAddress,timerTesting);
							return;	
						} 
					}
				};
************/
				//检测异常，调用异常继续寻找函数
				
			/*
		if(enableRetry) {debug.log.print("activeOutbound重试标志为：true")}
	else {	debug.log.print("activeOutbound重试标志为：false")
	}
*/				
				frmXray.onStartXrayFailed(outboundIndex,outboundAddress,enableRetry);
			},
			frmXray,outboundIndex,outboundAddress,xray.core.socksProxyPort,xray.core.getSystemProxyConfig(),enableRetry,timerTesting,config.proxy.outbounds
		)
	
		return true;	
	//debug.log.print("frmXray.isOnActive = 0")
	//frmXray.isOnActive = 0;
}


var autoUpdateSubscriptionTimerId; 
frmXray.autoUpdateSubscription = function(timeout){
		..win.clearTimeout(autoUpdateSubscriptionTimerId); 
		if(timeout===-1){
			autoUpdateSubscriptionTimerId = null;
			return;
		}
		
		if(config.subscribe.autoRefreshSubscription){
			autoUpdateSubscriptionTimerId = ..win.setTimeout(function(){
				autoUpdateSubscriptionTimerId = null;
				
				import xray.outbounds;
				xray.outbounds.autoUpdateSubscription(); 
			},timeout:10000)  		
		}
} 

//当代理服务器可用时
frmXray.onStartXrayComplete = function(outboundIndex,outboundAddress,timerTesting){
	
	var outbound = config.proxy.outbounds[outboundIndex];	
	if (outbound.address != outboundAddress ) return ; 
	config.proxy.outbounds[outboundIndex].failedCount = 0;//重置失败计数器
	//frmXray.listview.setItemText("",outboundIndex,8);
	// 停止自动更新
	frmXray.autoUpdateSubscription(-1);
	

	
	//记录本次可用日期时间
	config.proxy.outbounds[outboundIndex].lastValiable=tostring(time.now());
	//debug.log.print("序号："+outboundIndex+"lastValiable:")
	//console.dump(time(config.proxy.outbounds[outboundIndex].lastValiable))
	// 如果出站代理不存在，或者地址与给定地址不匹配，则退出函数
	if(!(outbound && (outbound.address == outboundAddress))){
		return;
	}
	
	var listview = frmXray.listview;
	frmXray.listview.ensureVisible(outboundIndex);//确保此行可见
	//清空所有出站代理的延迟测试结果
/*
	for b,v in table.eachIndex(config.proxy.outbounds){
		listview.setItemText("",b,8);
	}
*/
	
	// 停止自动测试，并更新 ListView 中出站代理的状态
	//frmXray.autoTesting = false;
	//if(outboundAddress == listview.getItemText(outboundIndex,2) )  
	listview.setItemText("活动服务器：正常",outboundIndex,8);
	
	// listview记录活动服务器地址
	listview.activeOutboundIndex = outboundIndex;	
	var address  = listview.getItemText(outboundIndex,2);
	// 如果定时可通测试，则打印新出站代理地址
	
	listview.activeOutboundAddress = address;//listview活动地址设置

	// 如果当前设定的出站代理为"不可用"，则清空其状态
/*
	if(listview.getItemText(outboundIndex,7)=="不可用"){
		listview.setItemText("",outboundIndex,7);
	}
*/
	
	// 重写回调函数，新的可用节点不再存储到frmXray.validOutbounds中
/*
	frmXray.onTcpingReturn = function(outboundIndex,address,succeeded,speedText){
		if(address==listview.getItemText(outboundIndex,2)){
			listview.setItemText(speedText,outboundIndex,7);
		}
	};
*/
	// 清空有效出站代理的列表
	//frmXray.validOutbounds = {};
	outbound.ps = "已测通";
	listview.setItemText("已测通",outboundIndex,6);
	// 恢复 TCPing 按钮
	frmXray.btnTcping.disabledText = null;
	//frmXray.btnChangeServer.text="换服务器"
	//frmXray.btnChangeServer.disabledText =null;
	//isOnSearching = false;
	import TrafficStats;
	
	// 发布当前活动出站代理的地址
	..publish("activeOutbound",address); 
	
	import debug.log
	/*
if(frmXray.chkSearchMode.checked ) {debug.log.print("chkSearchMode is checked")}
	else {
	debug.log.print("chkSearchMode not checked")
	}
*/


	
/*
	if(0 && frmXray.chkSearchMode.checked) {
		frmXray.edit.print("找到可用服务器，搜寻模式自动搜索下一个可用服务器"); 
				
		if(trafficTimerId){ 
			frmXray.clearInterval(trafficTimerId); 
		}
		listview.setItemText("可用,被切换掉",outboundIndex,8);//手动切换不能把当前代理服务器置为异常
				//frmXray.edit.print("手动更换服务器",listview.getItemText(outboundIndex,2)); 
		isOnSearching = true;
		
		frmXray.onStartXrayFailed(currentOutboundIndex,currentOutboundAddress,true);
		return ; 
		//frmXray.clearInterval(trafficTimerId);
	}
	elseif (frmXray.chkJustValid.checked) {
		//isOnSearching = false;
		//isManualSwitch=false;	
	}
	else {
		isOnSearching = false;
		//isManualSwitch=false;	
	}
*/
	
	if(!timerTesting) {
		
		frmXray.edit.print("已切换到服务器：",address);
		import TrafficStats;
		TrafficStats.start();//重置流量统计
		frmXray.trafficStats();//启动流量统计
		//frmXray.chkAutoTest.oncommand();
		//debug.debug();
		
	}
}

subscribe("activeOutbound",function(address){
	..globalActiveOutbound = address;
} )

//服务器代理功能异常,搜寻下一个服务器
frmXray.onStartXrayFailed = function(outboundIndex,outboundAddress,enableRetry){ 
	import debug
	import debug.log
/*
		if(enableRetry) {console.log("重试标志为：true")
		debug.traceback(,,9)
		}
	else {
	
	//debug.traceback(,,9)
	}
*/	
		
	//if(trafficTimerId){ frmXray.clearInterval(trafficTimerId); }
	//frmXray.listview.setItemText("",outboundIndex,8);
	
	
	..publish("activeOutbound",false); 
	//isOnSearching = true;
	

	var outbound = config.proxy.outbounds[outboundIndex];
	if(!(outbound && (outbound.address == outboundAddress))){
		return;
	}
	
	if(outbound.subscribeUrl){//如果开启"异常重新刷新订阅",则刷新
		frmXray.autoUpdateSubscription();
	} 
	
	var listview = frmXray.listview;
	listview.ensureVisible(outboundIndex);
	
	if(listview.activeOutboundIndex==outboundIndex){//重置listview的当前活动服务器
		listview.activeOutboundIndex=null;
		listview.activeOutboundAddress = null;
	}
	
	if(!isManualSwitch && !isOnSearching) {//手动切换不能把当前代理服务器置为不可用
			listview.setItemText("不可用",outboundIndex,7);
		}
		
	if(enableRetry){
		if(config.proxy.outbounds[outboundIndex].failedCount) {
			config.proxy.outbounds[outboundIndex].failedCount += 1;//失败计数器,手动模式时不起作用
			//debug.debug();
		}
		else {
			config.proxy.outbounds[outboundIndex].failedCount = 1;
		}
					
		if(#frmXray.validOutbounds){			
			var next = frmXray.validOutbounds[1];
			if(!config.proxy.outbounds[next[1]].replyDelay ) 	config.proxy.outbounds[next[1]].replyDelay = 2000;	
			var i;
			//debug.log.printf("表大小为："+#frmXray.validOutbounds);
			if(0 && frmXray.chkJustValid.checked){ //仅已测通			
/*
			if(config.proxy.outbounds[next[1]].downSpeed){
				for( i=2;#frmXray.validOutbounds;1 ){    
					var j =frmXray.validOutbounds[i];
					if(!config.proxy.outbounds[j[1]].downSpeed) {//找出下载速度最快的服务器,没有记录的优先使用
						next=frmXray.validOutbounds[i];
						break;
					}
					elseif(config.proxy.outbounds[next[1]].downSpeed<config.proxy.outbounds[j[1]].downSpeed){
						next=frmXray.validOutbounds[i];
					}
					
				}
			}
*/
			
				if(config.proxy.outbounds[next[1]].lastValiable){
					for( i=2;#frmXray.validOutbounds;1 ){    
						var j =frmXray.validOutbounds[i];
						if(!config.proxy.outbounds[j[1]].lastValiable) {//找出最新可用的服务器,没有记录的优先使用
							next=frmXray.validOutbounds[i];
							break;
						}
						elseif(time(config.proxy.outbounds[next[1]].lastValiable)<time(config.proxy.outbounds[j[1]].lastValiable)){
							next=frmXray.validOutbounds[i];
						}						
					}
				}
			
			}
			else {
/*
				for( i=2;#frmXray.validOutbounds;1 ){      //找出时延最少的服务器
						if (next[3]>frmXray.validOutbounds[i][3]){
							next=frmXray.validOutbounds[i]
							
						}
				}
*/
				
				if(config.proxy.outbounds[next[1]].failedCount){	
							
					for( i=2;#frmXray.validOutbounds;1 ){   					 
						var j =frmXray.validOutbounds[i];
						//if (!config.proxy.outbounds[j[1]].replyDelay ) config.proxy.outbounds[j[1]].replyDelay = 2000;					
						if(!config.proxy.outbounds[j[1]].failedCount) {//找出最近可用的服务器,没有记录的失败计数视为0
							next=j;
							break;
						}
						elseif(config.proxy.outbounds[next[1]].failedCount > config.proxy.outbounds[j[1]].failedCount){
							next=j;
						}
						elseif(config.proxy.outbounds[next[1]].failedCount == config.proxy.outbounds[j[1]].failedCount){
							if(!config.proxy.outbounds[j[1]].replyDelay ) 	config.proxy.outbounds[j[1]].replyDelay = 2000;	
							if (config.proxy.outbounds[next[1]].replyDelay > config.proxy.outbounds[j[1]].replyDelay )	next=j;
						}
						
					}
					/*
if(config.proxy.outbounds[next[1]].failedCount) debug.log.print("failedCount为"+config.proxy.outbounds[next[1]].failedCount);
					else {
						debug.log.print("failedCount为0或NULL");
					}
*/
					
				}				
			}
			
			//debug.log.print(next);
			var test = frmXray.listview.getItemText(next[1],2)
			if (test == next[2]) {
				//debug.log.printf("地址相同")
				}
			else {
			//debug.log.printf("地址不同,刷新重试!"+test);//不同说明表已经被别的线程改变,需重新测试
			frmXray.edit.print("列表有变动,正在刷新重测!");
			publish("uiCommand.restartxrayCore");//刷新视图，重新开始测速
			return;			
			}
			
			//debug.log.printf('索引号:'+next[1]+"地址:"+next[2]+"测试延时:"+next[3]+"毫秒，"+"表大小为："+#frmXray.validOutbounds+"服务器总数为:"+#..config.proxy.outbounds);
			frmXray.edit.print('正在测试服务器列表号:'+next[1]+"，服务器地址:"+next[2]+"，测试延时:"+next[3]+"毫秒，"+"剩余可测数量为："+#frmXray.validOutbounds+"，服务器总数为:"+#config.proxy.outbounds);
			//frmXray.edit.printf('正在测试服务器列表号:'+next[1]+"，服务器地址:"+next[2]+"，测试延时:"+next[3]+"毫秒，");
			//frmXray.edit.printf("剩余可测数量为："+#frmXray.validOutbounds+"，服务器总数为:"+#..config.proxy.outbounds);
					
			//if(frmXray.chkAutoTest.checked){ debug.log.print("frmXray.chkAutoTest.checked 为1")}
			
			
			if(isManualSwitch) {
				listview.setItemText("可用,被切换掉",outboundIndex,8);//手动切换不能把当前代理服务器置为异常
							//frmXray.edit.print("手动更换服务器",listview.getItemText(outboundIndex,2)); 
				isManualSwitch=false;	
			}			
			else {				
				listview.setItemText("异常,测试下一个...",outboundIndex,8);//手动切换不能把当前代理服务器置为不可用
				if(config.proxy.outbounds[outboundIndex].lastValiable) listview.setItemText("上次可用："+config.proxy.outbounds[outboundIndex].lastValiable,outboundIndex,8);
				elseif(config.proxy.outbounds[outboundIndex].failedCount){
					listview.setItemText("失败次数："+config.proxy.outbounds[outboundIndex].failedCount,outboundIndex,8);
				}
				
				frmXray.edit.print("服务器异常：",listview.getItemText(outboundIndex,2)); 
				frmXray.edit.print("正在尝试连接：",next[2]); 	
			}
			frmXray.clearInterval(trafficTimerId);
			//console.dump(config.proxy.outbounds[next[1]]);
			//activeOutbound(next[1],next[2],enableRetry);//根据是否勾选"重连"来决定是否要后面要继续
			switchOutbound(next[1],next[2],enableRetry);//根据是否勾选"重连"来决定是否要后面要继续
			..table.removeByValue(frmXray.validOutbounds,next);
				
		}
		else {
			
			frmXray.btnTcping.oncommand();
		}
	}
	else {
		
		listview.setItemText("活动服务器：异常",outboundIndex,8);
		//frmXray.edit.print("已切换到服务器：",listview.getItemText(outboundIndex,2)); 
		//activeOutbound(outboundIndex,outboundAddress,enableRetry,true);
		frmXray.autoTesting = false;
	} 
	
	//frmXray.btnTcping.disabledText = null;
	
}

// 延迟测试函数
var tcping = function(frmXray,outboundIndex,outbound){ 
	import wsock.tcp.client; 
	var timeout = 0; 
	var failed = 0;
	// 测试4次，取平均值作为延迟
	var client = wsock.tcp.client(); ; 
	var tickBegin
	for(i=1;5;1){ 
		sleep(1);
		//client = wsock.tcp.client(); 
		tickBegin = time.tick(); 
		
		if(client.connectTimeout(outbound.address,tonumber(outbound.port),3)){//连接成功的话（超时时间为3秒）
			// 发送成功的话，返回“.”的长度（1）给ret
			var ret = client.send("."); 
			
			//client.close();
			
			//io.print("第"+i+"次,回复为"+ret);
			
			// 没有发送成功
			if( ret == 1){  
				//frmXray.onTcpingReturn(outboundIndex,outbound.address,false,"不可用");
				timeout =  timeout + (time.tick() - tickBegin);
				//debug.log.print("第"+i+"次,回复为"+ret);
				continue
				//return;
			}
			failed++;
			// 累计时间，后面求平均值
			//timeout =  timeout + (time.tick() - tickBegin);
		}
		else {
			// 3秒超时的情况
			//client.close();
			
			failed++;
			
		} 
	}
	client.close();
	if(failed==5){ //原程序定义为只要有一次不成功就显示不可用，我改为一次都不成功才定义为“不可用”，避免出现服务器少时把免强可用的服务器给排除导致无服务器可用
		frmXray.onTcpingReturn(outboundIndex,outbound.address,false,"不可用");
		return;	
	} 
	// 调用的是frmXray.btnTcping.oncommand中的onTcpingReturn
	// 如果后面发现有调用其他地方的onTcpingReturn，则需要将该功能单独抽出来
	//frmXray.onTcpingReturn(outboundIndex,outbound.address,true,math.round(timeout / (8-failed) / 1000,2)+"秒"); 
		//if (!outboundIndex ){
			//debug.log.printf("测试结果:序号"+outboundIndex+"地址:"+outbound.address+"延迟:"+math.round((timeout+3000*failed) / 8000,3))
				//debug.log.printf("测试结果:序号"+outboundIndex)
	//debug.log.printf("测试结果:序号"+outboundIndex.tostring)
			//}

	frmXray.onTcpingReturn(outboundIndex,outbound.address,true,math.round((timeout+3000*failed) / 5,0)); 
};

//网络有问题的处理
var retryOnNetworkAliveTimerId;
frmXray.onTcpingFailed = function(){
	frmXray.autoTesting = false;
	frmXray.btnTcping.disabledText = null;	
	..publish("activeOutbound",false); 
	
	// 如果有值，就清除定时器
	if(retryOnNetworkAliveTimerId){
		frmXray.clearTimeout(retryOnNetworkAliveTimerId);
	}
	
	// 有没有网络
	if(inet.http.isAlive(,false)){
		// 有网络时，自动更新订阅
		frmXray.autoUpdateSubscription(1000);
	}
	else {
		// 没有网时，创建一个定时器，每隔1秒执行一次匿名函数
		retryOnNetworkAliveTimerId = frmXray.setInterval( 
			function(){ 
				// 如果有激活了的服务器，那么retryOnNetworkAliveTimerId设为空，
				// 并返回0，表示不再执行定时器函数
				if(frmXray.listview.activeOutboundIndex){
					retryOnNetworkAliveTimerId = null;
					return 0;
				}
				
				if(inet.http.isAlive(,false)){
					// 检测到有网后，重新测延迟，并清除定时器
					frmXray.btnTcping.oncommand();
					retryOnNetworkAliveTimerId = null;
					return 0;
				}	
			},1000
		) 
	}  
} 

import sysProxy; 
import style;
frmXray.btnTcping.skin(style.primaryButton);

var validAddresses;
//“检测并连接最快服务器”按钮函数定义
frmXray.btnTcping.oncommand = function(id,event){
	import debug
	import debug.log
	import console
	//debug.debug()
	if(trafficTimerId){ frmXray.clearInterval(trafficTimerId); }
	manualRunTimes = 0;//重置手动模式下循环次数计数器
	frmXray.chkAutoTest.checked=true;
	config.proxy.AutoTest=true;
	isManualSwitch = false;
	frmXray.listview.activeOutboundIndex = null;	//重置变量listview  activeOutboundIndex
	frmXray.listview.activeOutboundAddress = null;	//重置变量listview  activeOutboundAddress
	//frmXray.btnChangeServer.text="不可用"
	//frmXray.btnChangeServer.disabledText = {'\uF254';'\uF251';'\uF252';'\uF253';'\uF250'}
	frmXray.listview.clearColumnImage();
	
	var items = frmXray.listview.items;//获取列表视图行元素
	if(#items){//如果列表不为空	
		frmXray.btnTcping.disabledText = {'\uF254';'\uF251';'\uF252';'\uF253';'\uF250'}
		
		xray.core.lastDownloadingCoreFailed = false;
		// 如果没有找到 xray core，那么就退出函数
		if(!xray.core.getPath()){ //没有内核就返回
			frmXray.btnTcping.disabledText = null; 
			return;
		} 

		var failedCount = 0;//失败计数器
		
		//延时测试返回函数
		frmXray.onTcpingReturn = function(outboundIndex,address,succeeded,speedText){
			if(address!=frmXray.listview.getItemText(outboundIndex,2)){//看索引号与列表视图对应地址是否相同,不同则返回
				return; 
			} 
			// 无论连接是否成功，都要在列表视图显示延迟时间
			frmXray.listview.setItemText(speedText,outboundIndex,7);

			if(succeeded){
				// 接收到第一个成功返回的节点后，改写frmXray.onTcpingReturn，使后面的成功节点
				// 都只是放到frmXray.validOutbounds。之后激活第一个成功节点
				frmXray.validOutbounds = {};
				//debug.debug();
				frmXray.onTcpingReturn = function(outboundIndex,address,succeeded,speedText){//address为服务器地址
					if(address!=frmXray.listview.getItemText(outboundIndex,2)){
						return; 
					} 
					frmXray.listview.setItemText(speedText,outboundIndex,7);
					if(succeeded) {
						// 后续成功节点都放到全局变量frmXray.validOutbounds中
						table.push(frmXray.validOutbounds,{outboundIndex;address;speedText});
					}
					else{
						failedCount++;
						if(failedCount==#items) {
							frmXray.onTcpingFailed();
						}
					}
				}
				// 激活第一个节点
				// #items>1 表示节点数大于1时，启动重试。可能需要改成 #validOutbounds>0
				if(!config.proxy.outbounds[outboundIndex].replyDelay ) 	config.proxy.outbounds[outboundIndex].replyDelay = 2000;
				//console.dump(config.proxy.outbounds[outboundIndex]);
				//activeOutbound(outboundIndex,address,#items>1);	//address为服务器地址
				//debug.debug();
				switchOutbound(outboundIndex,address,#items>1);	//address为服务器地址
			}
			else{
				failedCount++;
				// 所有节点都不通时执行
				if(failedCount==#items) {
					frmXray.onTcpingFailed(); 
				}
			}
		}
		
		
		//开始配置测速
		import win
		import thread.manage;
		//if (manage) manage.threads={};
		manage = thread.manage(config.proxy.maxTestServers);//配置最大测速线程
		var outbounds = config.proxy.outbounds;
		//debug.log.print("视图数量:"+#items+"服务器数量:"+#outbounds);
		var listview = frmXray.listview;
		
		// 测速前，初始化显示内容
		try{
			for(i=1;#items;1){
				// 默认全部允许测速，不允许的话，需要手动勾选
				if(frmXray.chkJustValid.checked){
					if(outbounds[i].ps != "已测通"){
						listview.setItemText("禁止测速",i,7);					
						continue;
					}
				}
				elseif(frmXray.chkValidNoSearch.checked){
					if(outbounds[i].autoConnect === false || outbounds[i].ps == "已测通"){
						listview.setItemText("禁止测速",i,7);
						continue;
					}
				}
				else{
					if(outbounds[i].autoConnect === false){
						listview.setItemText("禁止测速",i,7);
						continue;
					}
				}
		
				listview.setItemText("...",i,7);
				//listview.setItemText("",i,8);
				//config.proxy.outbounds[i].lastValiable=tostring(time.now());
				//console.dump(time.now());
				//if(config.proxy.outbounds[i].lastValiable) listview.setItemText("上次可用："+config.proxy.outbounds[i].lastValiable,i,8);
				
				// 创建测速线程
				manage.create(tcping,frmXray,i,config.proxy.outbounds[i]);
			}
		}
		manage.waitClose(); 
		frmXray.btnTcping.disabledText = null;
	}
	else {
		if(id) frmXray.msgWarn("请先添加服务器")
		xray.core.stop();
		
		frmXray.btnTcping.disabledText = null;
		frmXray.autoTesting = false;
		frmXray.onTcpingReturn = function(outboundIndex,address,succeeded,speedText){};
	}
}

//手动切换下一个服务器
var manualRunTimes = 0;//用来防止配置为空时陷入死循环,要按"自动选择最快服务器才能清零"
frmXray.btnChangeServer.oncommand=function(){
	//frmXray.clearInterval(trafficTimerId);
	import console;
	import debug;
	import debug.log;	
	//console.dump(testTimerId);
	//debug.log.print(testTimerId);
	//debug.debug();
	
/*
	if(testTimerId){
		frmXray.clearInterval(testTimerId);	//删除定时器
	}
*/
	
	if (#validAddresses){//已经有可用服务器时才谈得上切换
		//debug.log.print("手动切换服务器,currentOutboundIndex为:"+currentOutboundIndex);
		//frmXray.chkAutoTest.checked=false;
		//frmXray.chkSearchMode.checked=false;
		frmXray.chkAutoTest.checked = false;
		//config.proxy.searchMode = false;		
		isManualSwitch = true;
		frmXray.edit.print("手动更换服务器"); 
		
		
			//var next = table.shift(frmXray.validOutbounds);			
			
			
		/*	var next = validAddresses[1];
			
			//debug.log.printf("表大小为："+#frmXray.validOutbounds);
			
for( i=2;#validAddresses;1 ){      //找出时延最少的服务器
				
				if ((next[3]?next[3]:0)<(validAddresses[i][3]?validAddresses[i][3]:0)){
					next=validAddresses[i]
					
					}
			}
*/			
			//[1]索引号，[2]地址，[3]最近可用时间
			var next = validAddresses[#validAddresses];
			if(next[3]){
				//console.dump(next[3]);
				//debug.log.print(time(next[3]));
				//sleep(10000)
				for( i=#validAddresses-1;1;-1 ){   
					//console.dump(   validAddresses[i][3]);
					//debug.log.print(time(validAddresses[i][3]));
					if(!validAddresses[i][3]) {//找出最近可用的服务器,没有记录的优先使用
						next=validAddresses[i];
						break;
					}
					elseif(next[3]<validAddresses[i][3]){
						next=validAddresses[i];
					}
					
				}
			}
			//debug.log.print(time(next[3]));
			//debug.log.print(next);
			var test = frmXray.listview.getItemText(next[1],2)
			//debug.log.print("test为："+test,"next[2]为："+next[2]+next[3]);
			if (test != next[2]) {
				frmXray.edit.print("列表有变动,正在刷新重测!");
				publish("uiCommand.restartxrayCore");//刷新视图，重新开始测速
				return;	
			}
			else {//debug.log.printf("地址相同")
			//debug.log.printf("地址不同,刷新重试!"+test);//不同说明表已经被别的线程改变,需重新测试
					
			}
			
			frmXray.edit.print('正在测试服务器列表号:'+next[1]+"，服务器地址:"+next[2]+"剩余可测数量为："+#validAddresses);
			..table.removeByValue(validAddresses,next);						
			
			if(frmXray.listview.activeOutboundAddress) frmXray.listview.setItemText("可用,被手动切换掉",outboundIndex,8);//手动切换不能把当前代理服务器置为异常
			//frmXray.edit.print("手动更换服务器",listview.getItemText(outboundIndex,2)); 
							
			//activeOutbound(next[1],next[2],true,false);	
			switchOutbound(next[1],next[2],true,false);	
			
			//frmXray.chkAutoTest.oncommand();
	}
	else {
		manualRunTimes ++;
		if(manualRunTimes <4) publish("uiCommand.restartxrayCore");//刷新视图，重新开始测速
		return ; 
	}		
	
}

import xray.core;
import xray.pacServer;
frmXray.onDestroy = function(){
	xray.core.stop();
	xray.pacServer.stop();
}

var pingThread = function( ip,frmXray ) {
	import icmp.ping; 
	var ping = icmp.ping(); 
	
	for(i=1;4;1){
		if( ping.perform(ip) ){
				frmXray.edit.print(ip,string.format( "Reply from %s: bytes=%d time=%dms TTL=%d"
				, ping.ip , #ping.requestData  , ping.echoReply.roundTripTime , ping.echoReply.options.ttl ) ); 
		}  
		else {
			frmXray.edit.print(ip,"Request timed out");
		}
		
	}
} 

//删除服务器函数
var removeOutbounds = function(selectedItems){
	
	//避免后台线程改变activeIndex
	frmXray.onTcpingReturn = function(outboundIndex,address,succeeded,speedText){}; 
	frmXray.btnTcping.disabledText = null;
	frmXray.autoTesting = false;
	
	//记录当前活动服务器信息
	var activeIndex = frmXray.listview.activeOutboundIndex;  
	var outbounds = config.proxy.outbounds;
	for(i=#outbounds;1;-1){ 
		var ob = outbounds[i];
		if(activeIndex==i){
			ob.active = true;
		}
	}

	if(#selectedItems){//如果传进来的参数包含要删除的服务器,全部删除
		for(i=#selectedItems;1;-1){
			var item = selectedItems[i] 
			frmXray.listview.delItem(item);
			..table.remove(config.proxy.outbounds,item);
		}
	}
	else{//如果没有传参,那么删除不可用服务器
		for(i=#outbounds;1;-1){ 	
			//if(frmXray.listview.getItemText(i,7)=="不可用"){
			if(frmXray.listview.getItemText(i,7)=="不可用"&&outbounds[i].ps !="已测通"){//此处我修改为测通过的服务器不删除
				..table.remove(outbounds,i);
				frmXray.listview.delItem(i);
			} 
		}
	}

	frmXray.listview.activeOutboundIndex = null;
	for(i=1;#outbounds;1){//重新恢复listview的活动服务器
		if(outbounds[i].active){
			frmXray.listview.activeOutboundIndex = i;
			break;
		}
	}
	publish("outbounds.updateConfigJson"); 
	config.proxy.save();
//debug.log.print(frmXray.listview.activeOutboundIndex)

//如果之前就没有活动服务器,重新开始测时搜索
	/*
if(!activeIndex && (!frmXray.listview.activeOutboundIndex) ){
		if(!xray.core.lastDownloadingCoreFailed) {
			//debug.log.print("btnTcping.oncommand running!")
			frmXray.btnTcping.oncommand();//删除服务器后原测时列表已经失效,需重新测试
					
		}
	}
*/
}

//列表消息响应
import xray.outbounds;
frmXray.listview.onnotify = function(id,code,ptr){
	select(code) {
		case 0xFFFFFFF4/*_NM_CUSTOMDRAW*/ {
			var lvcd = frmXray.listview.getNotifyCustomDraw(code,ptr);
			if( lvcd.nmcd.dwDrawStage == 0x10001/*_CDDS_ITEMPREPAINT*/)
				return 0x20/*_CDRF_NOTIFYSUBITEMDRAW*/
			elseif( lvcd.nmcd.dwDrawStage == 1/*_CDDS_PREPAINT*/ ){
				return 0x20/*_CDRF_NOTIFYITEMDRAW*/;
			}
			elseif( lvcd.nmcd.dwDrawStage == ( 0x10001/*_CDDS_ITEMPREPAINT*/ | 0x20000/*_CDDS_SUBITEM*/) ){ 
				//注意这里 iSubItem 的索引自0开始( 其他函数通常自1开始 )
				lvcd.clrText = lvcd.nmcd.dwItemSpec % 2 ? 0x373737 : 0;
				lvcd.clrTextBk = lvcd.nmcd.dwItemSpec % 2 ? 0xFFFFFF : 0xF5F5F5;
				
				var item = lvcd.nmcd.dwItemSpec+1;
				if(lvcd.iSubItem==7){ 
					if(frmXray.listview.activeOutboundIndex=item){ 
						lvcd.clrTextBk = 0x8AFFC3
					} 
				}
				elseif(lvcd.iSubItem==6){ 
					if(config.proxy.outbounds[item].autoConnect===false){ 
						lvcd.clrText = 0xCCCCCC;
					} 
				}
				lvcd.update()
				
				return 0/*_CDRF_DODEFAULT*/
			}
		}
		case 0xFFFFFFFD/*_NM_DBLCLK*/ {//双击
			var nm = frmXray.listview.getNotifyMessage(code,ptr);
			if( nm ){
				frmXray.chkAutoTest.checked=false;//手动选择服务器后不再异常重连
				//frmXray.chkAutoTest.oncommand();
				import debug.log
				//if(!frmXray.chkSearchMode.checked) {debug.log.print("chkSearchMode.checked is unchecked")}
				xray.core.lastDownloadingCoreFailed = false;
				
				frmXray.onTcpingReturn = function(outboundIndex,address,succeeded,speedText){
					if(address==frmXray.listview.getItemText(outboundIndex,2)){
						frmXray.listview.setItemText(speedText,outboundIndex,7);
					} 
				}
				frmXray.btnTcping.disabledText = null;
				
				/*
for b,v in table.eachIndex(config.proxy.outbounds){
					frmXray.listview.setItemText("",b,8);
				}
*/
				//activeOutbound(nm.iItem,frmXray.listview.getItemText(nm.iItem,2),false); 
				switchOutbound(nm.iItem,frmXray.listview.getItemText(nm.iItem,2),false,false); 
			}
		}
		case 0xFFFFFFFB/*_NM_RCLICK*/  {//右键
			var x,y = win.getCursorPos();
			var nm = frmXray.listview.getNotifyMessage(code,ptr);
			if(!nm) return;

			var currentIdx = nm.iItem;
			if(!currentIdx){
				var popmenu = win.ui.popmenu(frmXray);
				popmenu.add("新增代理服务器",function(id){ 
					var frmOutbound = frmXray.loadForm("\forms\main\outbound.aardio"); 
					frmOutbound.doModal() 
				});
				
				popmenu.add("自剪贴板批量导入分享链接、订阅源",function(id){
					frmXray.btnImportServerFromClipBd.oncommand();
				});
				
				popmenu.add('立即更新所有订阅源',function(id){
					xray.outbounds.updateSubscription();
					frmXray.removeRepeat();//更新所有订阅源后消除重复服务器
				});
				
				popmenu.add(); 				
				
				popmenu.add('清除「不可用」节点',function(id){
					frmXray.clearInterval(trafficTimerId);
					removeOutbounds();
				});	
				
				popmenu.add('清除「重复」节点',function(id){
					var removecount = frmXray.removeRepeat();
					if(removecount){
						frmXray.edit.print("删除了"+removecount+"个节点")
						}
				});
				
				popmenu.add('清空服务器列表',function(id){
					config.proxy.outbounds = ..table.array();
					frmXray.listview.clear();
					
					frmXray.btnTcping.disabledText = null;
					frmXray.autoTesting = false;
					frmXray.onTcpingReturn = function(outboundIndex,address,succeeded,speedText){}  
					publish("outbounds.updateConfigJson");
				});
				
				popmenu.add();
				
				if(!frmXray.btnTcping.disabledText){
					popmenu.add('按「响应速度」排序服务器',function(id){
						frmXray.listview.sortBySpeed();
					});	 
					popmenu.add();
				}; 
				popmenu.popup(x,y,true);
				return;
			}
			
			var selectedItems = frmXray.listview.selected; 
			var popmenu = win.ui.popmenu(frmXray);
			
			if(#selectedItems==1){
				popmenu.add('设为活动服务器( 鼠标双击 )',function(id){
					if(currentIdx){
						xray.core.lastDownloadingCoreFailed = false;
						
						frmXray.onTcpingReturn = function(outboundIndex,address,succeeded,speedText){
							if(address==frmXray.listview.getItemText(outboundIndex,2)){
								frmXray.listview.setItemText(speedText,outboundIndex,7);
							} 
						}
						
						frmXray.btnTcping.disabledText = null;
						
/*
						for b,v in table.eachIndex(config.proxy.outbounds){
							frmXray.listview.setItemText("",b,8);
						}
*/
						//activeOutbound(currentIdx,frmXray.listview.getItemText(currentIdx,2),false)
						switchOutbound(currentIdx,frmXray.listview.getItemText(currentIdx,2),false)
					}
				});

				popmenu.add();
			}
			 
			popmenu.add("编辑 / 新增代理服务器",function(id){ 
				var frmOutbound = frmXray.loadForm("\forms\main\outbound.aardio");
				frmOutbound.setOutboundConfig(config.proxy.outbounds[currentIdx]);
				frmOutbound.doModal() 
			});
			
			popmenu.add("自剪贴板批量导入分享链接、订阅源",function(id){
				frmXray.btnImportServerFromClipBd.oncommand();
			});
			 
			var subscribeUrl = config.proxy.outbounds[currentIdx][["subscribeUrl"]];
			if(#selectedItems=1 && subscribeUrl){
				
				var ps;
				var cfgSubscribeUrls = config.subscribe.subscribeUrls;
				for(i=#cfgSubscribeUrls;1;-1){
					var sub = cfgSubscribeUrls[i]  
					if(sub.url===subscribeUrl) {
						ps = sub.ps;
						break;
					}
				}
				
				if(#ps){
					ps = ": "+ps;
				}
			
				if(ps) popmenu.add('更新当前订阅源'+ps,function(id){
					if(currentIdx){
						xray.outbounds.updateSubscription({[subscribeUrl]=true});
						frmXray.removeRepeat();//更新后消除重复服务器
					}
				});	
			}

			popmenu.add('更新所有订阅源',function(id){
				if(currentIdx){
					xray.outbounds.updateSubscription();
					frmXray.removeRepeat();//更新所有订阅源后消除重复服务器
				}
			});	
			 
			popmenu.add()

			var autoConnect = config.proxy.outbounds[currentIdx].autoConnect!==false; 
			var id = popmenu.add('允许自动测速并连接',function(id){
				if(currentIdx){
					for(i=#selectedItems;1;-1){ 
						var item = selectedItems[i];
						if(autoConnect === false){
							config.proxy.outbounds[item].autoConnect = null;
							//frmXray.listview.setItemText("",item,7);
						}
						else {
							config.proxy.outbounds[item].autoConnect = false;
							frmXray.listview.setItemText("禁止测速",item,7);
						}
					}
				}
			});
			popmenu.check(id,autoConnect,0/*_MF_BYCOMMAND*/); 
			popmenu.add()
			
			popmenu.add('删除服务器',function(id){
				removeOutbounds(selectedItems);
				publish("uiCommand.restartxrayCore");	
			});
				
			
			
			popmenu.add('清除「不可用」节点',function(id){
				removeOutbounds();
			});	
			
			popmenu.add('清除「重复」节点',function(id){
				var removecount = frmXray.removeRepeat();
				if(removecount){
					frmXray.edit.print("删除了"+removecount+"个节点")
					}
				});
				
			popmenu.add('清空服务器列表',function(id){
				if(currentIdx){
					config.proxy.outbounds = ..table.array();
					frmXray.listview.clear();
					publish("outbounds.updateConfigJson");
				}
			});	
			 
			if(#selectedItems==1){	
		 
				popmenu.add();
				popmenu.add('生成二维码',function(id){
					if(currentIdx){
						import xray.outbounds;
						import win.clip;
						
						var str = xray.outbounds.exportSharedLinks({config.proxy.outbounds[currentIdx]});
						if(str){ 
							var frmChild = frmXray.loadForm("\forms\main\tools\qr.aardio");
							frmChild.createQrCode(str);
							frmChild.show();
						}  
					}
				});
				
				popmenu.add('复制服务器分享链接',function(id){
					if(currentIdx){
						import xray.outbounds;
						import win.clip;
						
						var str = xray.outbounds.exportSharedLinks({config.proxy.outbounds[currentIdx]});
						if(str){ 
							win.clip.write(str); 
							frmXray.edit.print("已复制链接:",str);
						}  
					}
				});

				popmenu.add();
				
				var toolMenu = win.ui.popmenu(frmXray)
				toolMenu.add('本机 Ping 检测',function(id){
					if(currentIdx){
						thread.invoke(pingThread,config.proxy.outbounds[currentIdx].address,frmXray)
					}
				});
					
				toolMenu.add('全球范围 Ping 检测 ...',function(id){
					if(currentIdx){
						process.openUrl("http://ping.pe/" + config.proxy.outbounds[currentIdx].address)
					}
				});
				
				toolMenu.add('全球范围端口检测 ...',function(id){
					if(currentIdx){
						process.openUrl("http://port.ping.pe/" + config.proxy.outbounds[currentIdx].address + ":" + config.proxy.outbounds[currentIdx].port)
					}
				});
				
				toolMenu.add('在线路由跟踪检测 ...',function(id){
					if(currentIdx){
						process.openUrl("https://www.boce.com/traceroute/" + config.proxy.outbounds[currentIdx].address)
					}
				});
				
				toolMenu.add('本机路由检测',function(id){
					if(currentIdx){
						import process;
						process.execute("cmd.exe","/k tracert " + config.proxy.outbounds[currentIdx].address);
					}
				});

				if(config.proxy.outbounds[currentIdx].port == 443 && config.proxy.outbounds[currentIdx].tls){
					toolMenu.add('浏览 HTTPS 主页 ...',function(id){
						if(currentIdx){
							process.openUrl("https" ++ "://" + config.proxy.outbounds[currentIdx].address); 
						}
					});	 
				}
				
				popmenu.add("服务器工具",toolMenu)
				
				popmenu.add('SSH 登录服务器',function(id){
					if(currentIdx){
						if(_STUDIO_INVOKED){
							frmXray.msgErr("请在发布后运行此功能");
							return;
						}
						import process;
						process.execute(io._exepath,"/sshLogin root@" 
							+ config.proxy.outbounds[currentIdx].address + ":" 
							+ (config.proxy.outbounds[currentIdx].sshPort||22));
					}
				});  
			}
			if(#selectedItems>1){
				popmenu.add();
				popmenu.add('批量生成二维码',function(id){
					if(currentIdx){
						var outbounds = ..table.array();
						for(i=1;#selectedItems;1){
							..table.push(outbounds,config.proxy.outbounds[selectedItems[i]]);
						}
						
						var str = xray.outbounds.exportSharedLinks(outbounds);
						if(str){
							var frmChild = frmXray.loadForm("\forms\main\tools\qr.aardio");
							frmChild.createQrCode(str);
							frmChild.show();
						}  
					}
				});
				
				popmenu.add('批量复制服务器分享链接',function(id){
					if(currentIdx){
						var outbounds = ..table.array();
						for(i=1;#selectedItems;1){
							..table.push(outbounds,config.proxy.outbounds[selectedItems[i]]);
						}
						
						var str = xray.outbounds.exportSharedLinks(outbounds);
						if(str){
							import win.clip;
							win.clip.write(str);
							frmXray.msgOk("已将选中链接的分享链接写入剪贴板",1200);
						}	
					}
				});

				popmenu.add();
			}
			
			popmenu.popup(x,y,true);
		}
		case 0xFFFFFF94/*_LVN_COLUMNCLICK*/{
			var nm = frmXray.listview.getNotifyMessage(code,ptr)
			if(nm.iSubItem==7){
				frmXray.listview.sortBySpeed();
			} 
			elseif(nm.iSubItem==8){
				frmXray.listview.sortByLastValidDate();
			}
			elseif(nm.iSubItem==12){
				frmXray.listview.sortByMaxDownSpeed();
			}			
			else {
				frmXray.msgWarn("排序请点击「响应速度」列")
			}
		}
	}
}

// 按响应速度排序函数
frmXray.listview.sortBySpeed = function () {
	if(frmXray.btnTcping.disabledText){
		frmXray.msgWarn("请等待测速完成，然后再点击此排序列。",1000);
		return;
	}
	
	var outbounds = ..table.clone(config.proxy.outbounds);
	var activeIndex = frmXray.listview.activeOutboundIndex;
	frmXray.onTcpingReturn = function(outboundIndex,address,succeeded,speedText){}; //避免后台线程改变activeIndex
	
	for(i=#outbounds;1;-1){
		var ob = outbounds[i];
		if(type(ob)!="table"){
			table.remove(outbounds,i);
			continue;
		}
		
		ob.speed = frmXray.listview.getItemText(i,7);
		if(ob.speed=="不可用"){
			ob.speedNum = 0xFFFE;
		}
		elseif(ob.speed==""){
			ob.speedNum = 0xFFFF;
		}
		elseif(ob.speed=="..."){
			frmXray.msgWarn("请等待检测速度完成，然后再点击此排序列。",1000)
			return;
		}
		else {
			ob.speedNum = tonumber(ob.speed):-3;
		} 
		
		if(activeIndex==i){
			ob.active = true;
		}
	}
	
	var hasStatus;
	for(i=1;#outbounds;1){
		if(#outbounds[i].speed){
			hasStatus = true;
			break;
		}
	}
	
	if(!hasStatus){
		frmXray.msgWarn("请先点击「检测并连接服务器」获取服务器响应速度！");
		return;
	}
	
	var desc = frmXray.listview.getColumnImage(7) == 0;
	if(desc){
		table.sort(outbounds,function(b){ 
			return owner.speedNum > b.speedNum;
		})	
	}
		else {
			table.sort(outbounds,function(b){ 
			return owner.speedNum < b.speedNum;
		})
		} 
	
	frmXray.listview.activeOutboundIndex = null;
	for(i=1;#outbounds;1){
		if(outbounds[i].active){
			frmXray.listview.activeOutboundIndex = i;
			break;
		}
	}
	
	outbounds.fields = {"protocol";"address";"port";"security";"network";"ps";"speed"}
	config.proxy.outbounds = outbounds;
	frmXray.listview.setTable(outbounds);	
	outbounds.fields = {"protocol";"address";"port";"security";"network";"ps"}
	
	//清理用于排序的临时字段
	for(i=1;#outbounds;1){
		var ob = outbounds[i];
		ob.speedNum = null;
		ob.speed = null;
		ob.active = null;
	} 
	
	if(frmXray.listview.activeOutboundIndex){
		frmXray.listview.setItemText("活动服务器：正常",frmXray.listview.activeOutboundIndex,8)
	} 
	frmXray.listview.setColumnImage(7, desc ? 1 : 0);
}

// 按历史最大下载速度排序函数
frmXray.listview.sortByMaxDownSpeed = function () {
	if(frmXray.btnTcping.disabledText){
		frmXray.msgWarn("请等待测速完成，然后再点击此排序列。",1000);
		return;
	}
	
	var outbounds = ..table.clone(config.proxy.outbounds);
	var activeIndex = frmXray.listview.activeOutboundIndex;
	frmXray.onTcpingReturn = function(outboundIndex,address,succeeded,speedText){}; //避免后台线程改变activeIndex
	
	for(i=#outbounds;1;-1){
		var ob = outbounds[i];
		if(type(ob)!="table"){
			table.remove(outbounds,i);
			continue;
		}
		
		//ob.speed = ob.downSpeed;
		if(!ob.downSpeed){
			ob.downSpeed = 0x0;
		}		
		/*
else {
			ob.speedNum = ob.downSpeed;
		} 
*/
		
		if(activeIndex==i){
			ob.active = true;
		}
	}
	
/*
	var hasStatus;
	for(i=1;#outbounds;1){
		if(#outbounds[i].speed){
			hasStatus = true;
			break;
		}
	}
	
	if(!hasStatus){
		frmXray.msgWarn("无速度记录");
		return;
	}
*/
	
	var desc = frmXray.listview.getColumnImage(12) != 0;
	if(desc){
		table.sort(outbounds,function(b){ 
			return owner.downSpeed > b.downSpeed;
		})	
	}
		else {
			table.sort(outbounds,function(b){ 
			return owner.downSpeed < b.downSpeed;
		})
		} 
	
	frmXray.listview.activeOutboundIndex = null;
	for(i=1;#outbounds;1){
		if(outbounds[i].active){
			frmXray.listview.activeOutboundIndex = i;
			break;
		}
	}
	for(i=1;#outbounds;1){
		var ob = outbounds[i];
		if(!ob.downSpeed) ob.downSpeed =null;
		//ob.speedNum = null;
		//ob.speed = null;
		ob.active = null;
	} 
	//outbounds.fields = {"protocol";"address";"port";"security";"network";"ps";"speed"}
	config.proxy.outbounds = outbounds;
	//frmXray.listview.setTable(outbounds);	
	//outbounds.fields = {"protocol";"address";"port";"security";"network";"ps"}
	publish("uiCommand.restartxrayCore");
	//清理用于排序的临时字段
	
	
	if(frmXray.listview.activeOutboundIndex){
		frmXray.listview.setItemText("活动服务器：正常",frmXray.listview.activeOutboundIndex,8)
	} 
	frmXray.listview.setColumnImage(12, desc ? 1 : 0);
}

// 按上次可用时间排序函数
frmXray.listview.sortByLastValidDate = function () {
	if(frmXray.btnTcping.disabledText){
		frmXray.msgWarn("请等待测速完成，然后再点击此排序列。",1000);
		return;
	}
	
	var outbounds = ..table.clone(config.proxy.outbounds);
	var activeIndex = frmXray.listview.activeOutboundIndex;
	frmXray.onTcpingReturn = function(outboundIndex,address,succeeded,speedText){}; //避免后台线程改变activeIndex
	
	for(i=#outbounds;1;-1){
		var ob = outbounds[i];
		if(type(ob)!="table"){
			table.remove(outbounds,i);
			continue;
		}
		
		//ob.speed = ob.downSpeed;
		if(!ob.lastValiable){
			ob.lastValiable = 0x0;
		}		
		/*
else {
			ob.speedNum = ob.downSpeed;
		} 
*/
		
		if(activeIndex==i){
			ob.active = true;
		}
	}
	
/*
	var hasStatus;
	for(i=1;#outbounds;1){
		if(#outbounds[i].speed){
			hasStatus = true;
			break;
		}
	}
	
	if(!hasStatus){
		frmXray.msgWarn("无速度记录");
		return;
	}
*/
	
	var desc = frmXray.listview.getColumnImage(8) != 0;
	if(desc){
		table.sort(outbounds,function(b){ 
			return time(owner.lastValiable) > time(b.lastValiable);
		})	
	}
		else {
			table.sort(outbounds,function(b){ 
			return time(owner.lastValiable) < time(b.lastValiable);
		})
		} 
	
	frmXray.listview.activeOutboundIndex = null;
	for(i=1;#outbounds;1){
		if(outbounds[i].active){
			frmXray.listview.activeOutboundIndex = i;
			break;
		}
	}
	for(i=1;#outbounds;1){
		var ob = outbounds[i];
		if(!ob.lastValiable) ob.lastValiable =null;
		//ob.speedNum = null;
		//ob.speed = null;
		ob.active = null;
	} 
	//outbounds.fields = {"protocol";"address";"port";"security";"network";"ps";"speed"}
	config.proxy.outbounds = outbounds;
	//frmXray.listview.setTable(outbounds);	
	//outbounds.fields = {"protocol";"address";"port";"security";"network";"ps"}
	publish("uiCommand.restartxrayCore");
	//清理用于排序的临时字段
	
	
	if(frmXray.listview.activeOutboundIndex){
		frmXray.listview.setItemText("活动服务器：正常",frmXray.listview.activeOutboundIndex,8)
	} 
	frmXray.listview.setColumnImage(8, desc ? 1 : 0);
}

//移除重复节点(保留序号在前的)
frmXray.removeRepeat=function(){
	//跳过检测异常
	frmXray.listChanging = true;//列表被改变标志
	//避免后台线程改变activeIndex
	frmXray.onTcpingReturn = function(outboundIndex,address,succeeded,speedText){}; 
	frmXray.btnTcping.disabledText = null;
	frmXray.autoTesting = false;
	//标记活动节点
	var activeIndex,activeText = frmXray.listview.activeOutboundIndex;  
	var outbounds = ..table.clone(config.proxy.outbounds);
	if( activeIndex ){
		outbounds[activeIndex].active = true;
		activeText = frmXray.listview.getItemText(activeIndex);
	}
	//标记重复节点
	for(i=1;#outbounds;1){
		for(j=i+1;#outbounds;1){
			//if( j<=i ){ continue }
			if( outbounds[j].address==outbounds[i].address 
				&& outbounds[j].port==outbounds[i].port ){
				outbounds[j].repeat=true;
			}
		}
	}
	//删除重复节点
	var removecount=0;
	for(i=#outbounds;1;-1){
		if(outbounds[i].repeat){
			table.remove(outbounds,i);
			removecount++;
		}
	}
	//重设活动节点序号
	frmXray.listview.activeOutboundIndex = null;
	for(i=1;#outbounds;1){
		var ob = outbounds[i];
		if(ob.active){
			frmXray.listview.activeOutboundIndex = i;
			activeIndex = i;
		}
		ob.repeat = null;
		ob.active = null;
	}
	//保存配置文件
	config.proxy.outbounds = outbounds;
	config.proxy.save();
	//frmXray.listview.setTable(outbounds);//刷新视图
	
//重新测速
	publish("uiCommand.restartxrayCore");//刷新视图，重新开始测速

	//继续检测异常
	frmXray.listChanging = false;
	
	return removecount; 
}
//按键
import win.ui.accelerator;
var accelerator = win.ui.accelerator({
	{//按下Enter键
		vkey = '13';
		oncommand=function(){
			frmXray.btnTcping.oncommand();			
		}	   
	};
	{ //按下DELETE键
		vkey = '46'; 
		oncommand = function(){
			var selectedItems = frmXray.listview.selected;
			removeOutbounds(selectedItems);
		}
	};
	{ //按下ctrl+C
		ctrl = true; vkey = 'C'#; 
		oncommand = function(){
			var selectedItems = frmXray.listview.selected;
			if( !#selectedItems ){
				frmXray.msgFrown("没有选中节点！");
				return ; 
			}
			
			var outbounds = ..table.array();
			for(i=1;#selectedItems;1){..table.push(outbounds,config.proxy.outbounds[selectedItems[i]])}
			var str = xray.outbounds.exportSharedLinks(outbounds);
			if(str){
				import win.clip;
				win.clip.write(str);
				frmXray.msgOk("已将选中节点的分享链接写入剪贴板",1200);
			}
		}
	};
	{//ctrl+V
		ctrl = true; vkey = 'V'#;
		oncommand=function(){
			frmXray.btnImportServerFromClipBd.oncommand();
		}
	};
	{//ctrl+A
		ctrl = true; vkey = 'A'#;
		oncommand=function(){
			var outbounds=config.proxy.outbounds;
			for(i=#outbounds;1;-1){
				frmXray.listview.setSelected(i);
			}
		}
	};
},frmXray);
//文件拖放
frmXray.onDropFiles = function(files){
	for(i=1;#files;1){
		var bmp = gdip.bitmap(files[i]);
		if(bmp){
			import zbar;
			var scanner = zbar.scanner();
			scanner.config('qrcode.enable');
			scanner.scanBitmap(bmp,function(typeName,data){  
		    	import win.clip;
				win.clip.write(data);
				
				var outbounds = xray.outbounds.importFromString(data);
					if(#outbounds){
						..table.append(config.proxy.outbounds,outbounds); 
						publish("uiCommand.restartxrayCore");
						publish("outbounds.updateConfigJson");
						frmXray.msgOk("已成功导入" + #outbounds + "个服务器",1200); 
						return; 
			           }
			    })					
	 } 
	 
		var str=string.load(files[i]);
		if(str){
			str = ..string.trim(str,'"\'\t\r\n '); 
	
			var outbounds = xray.outbounds.importFromString(str);
					if(#outbounds){
						..table.append(config.proxy.outbounds,outbounds); 
						publish("uiCommand.restartxrayCore");
						publish("outbounds.updateConfigJson");
						frmXray.msgOk("已成功导入" + #outbounds + "个服务器",1200); 
						return; 
					}
		}
	}
	//frmXray.msgFrown('未能在文件中导入节点!');
}

import win.imageList;
var iml = win.imageList(16, 15);
iml.add('GIF\56\57a \0\15\0\x80\0\0\x80\x80\x80\xff\0\xff\33\xf9\4\0\0\0\0\0\44\0\0\0\0 \0\15\0\0\2\31\x8c\x8f\xa9\xcb\xed\15\xa3\x9c\xb4N\xf0\x80\xde\56k\xbfA\\\xd7\x84 \x97Y\xea\xca\xb6\xee\11\xc7F\1\0;', 0xff00ff);
frmXray.listview.setColumnImageList(iml);



// 初始化列表视图，并测速、连接
subscribe("uiCommand.restartxrayCore",function(){ 
	started = xray.core.restart(frmXray.edit,config.proxy.outbounds[currentOutboundIndex]);//重启内核
	var outbounds = config.proxy.outbounds;
	for(i=#outbounds;1;-1){	//移除非法及失效服务器项
		//config.proxy.outbounds[i].failedCount = 0;
				
		//console.dump(outbounds[i].failedCount);
		//sleep(100);
		
		if(type(outbounds[i])!="table" || ( outbounds[i].failedCount &&  outbounds[i].failedCount > 50 ) ){
			debug.log.print("outbounds["+i+"].failedCount = "+outbounds[i].failedCount+",删除");
			table.remove(outbounds,i);
		}
	}	
/*
		if(config.proxy.outbounds[i].failedCount && config.proxy.outbounds[i].failedCount > 20){//移除失败次数太多的服务器
			table.remove(outbounds,i);
		}
*/
	
	//初始化手动切换服务器用列表
	validAddresses = {};
	var i;
	for(i=1;#outbounds;1){//初始化手动切换列表
		if(outbounds[i].ps="已测通") {table.push(validAddresses,{i,outbounds[i].address,time(outbounds[i].lastValiable)});	}
	}	
	config.proxy.outbounds.fields = {"protocol";"address";"port";"security";"network";"ps";}
	
	//初始化列表视图	
	frmXray.listview.setTable(outbounds); 	
	//var outer;
	for(i=1;#outbounds){		
		try{
			var a =outbounds[i].trafficUp;
			var b = outbounds[i].trafficDown;
			var c = outbounds[i].upSpeed;
			var d = outbounds[i].downSpeed;
			
			if(config.proxy.outbounds[i].lastValiable) {
				frmXray.listview.setItemText("上次可用："+config.proxy.outbounds[i].lastValiable,i,8);
			}
			elseif(outbounds[i].failedCount){
				frmXray.listview.setItemText("失败次数："+outbounds[i].failedCount,i,8);
				//listview.ensureVisible(i);
				//sleep(200)
				//debug.debug();
			}
			if(a)	{ frmXray.listview.setItemText(math.size64(a).format(),i,9); }
			if(b)	{ frmXray.listview.setItemText(math.size64(b).format(),i,10); }
			if(c)	{ frmXray.listview.setItemText(math.size64(c).format(),i,11); }
			if(d)	{ frmXray.listview.setItemText(math.size64(d).format(),i,12); }
			//debug.log.print(a)
		}
		
		//if(outbounds[i].upTraffic) debug.log.print(outbounds[i].upTraffic)}		
	}
	//debug.debug()
	frmXray.listview.fillParent();//使指定列自适应父窗口宽度,如果不指定列默认调整最后一列,用户调整窗口大小时会自动调用此函数调整自适应列
	// 程序首次执行时，lastDownloadingCoreFailed没有定义，所以下面一定会执行
	if(frmXray.chkAutoTest.checked){
		if(!xray.core.lastDownloadingCoreFailed) frmXray.btnTcping.oncommand();//转“检测并连接最快服务器”按钮函数执行
	}
	else {
		frmXray.btnChangeServer.oncommand();
	}
	frmXray.chkSearchMode.oncommand();
	
} )

import process;

//读配置
if(config.proxy.AutoTest == "true"){
	frmXray.chkAutoTest.checked = true;
	//frmXray.chkAutoTest.oncommand();//调用设置异常检测计时器
}
frmXray.chkValidNoSearch.checked = config.proxy.chkValidNoSearch;

if(config.proxy.searchMode == "true") {
	frmXray.chkSearchMode.checked = true;
	//frmXray.chkSearchMode.oncommand();
}
if(config.proxy.chkJustValid == "true"){
	frmXray.chkJustValid.checked = true;
}
//frmXray.chkAutoTest.oncommand();//设置异常检测计时器
frmXray.chkAutoTest.skin(style.checkBox);

// 程序真正入口

// 如果有代理节点，延迟1秒发布"uiCommand.restartxrayCore"
if(#config.proxy.outbounds){
	frmXray.setTimeout( 
		function(){
			publish("uiCommand.restartxrayCore");	
		},1000
	);	
}


// 订阅代理切换消息，设置3个单选控件
subscribe("sysProxy.modeChanged",function(mode){
	frmXray.radioProxyPac.checked = false;
	frmXray.radioProxy.checked = false;
	frmXray.radioProxyDirect.checked = false;
	
	if(mode = "pac"){
		frmXray.radioProxyPac.checked = true;
		if(_WIN10_LATER) frmXray.btnEditPacOrUwp.text = "编辑 PAC";
	}
	elseif(mode = "proxy"){
		frmXray.radioProxy.checked = true;
		if(_WIN10_LATER) frmXray.btnEditPacOrUwp.text = "配置 UWP";
	}
	else{
		frmXray.radioProxyDirect.checked = true;
	}
} )

//发布代理模式切换消息
publish("sysProxy.modeChanged",config.proxy.mode);

//代理模式切换处理函数
import sysProxy;
var switchProxyMode = function(){
	if(frmXray.radioProxyPac.checked){
		sysProxy.switchToPacMode();	
	}
	elseif(frmXray.radioProxy.checked){
		sysProxy.switchToGlobalMode();	
	}
	else {
		sysProxy.switchToDirectMode();	
	}  
}
//3个切换代理模式响应函数
frmXray.radioProxyPac.oncommand = switchProxyMode;
frmXray.radioProxy.oncommand = switchProxyMode;
frmXray.radioProxyDirect.oncommand = switchProxyMode;

//编辑PacOrUwp按钮
import win.dlg.message; 
frmXray.btnEditPacOrUwp.skin(style.plainButton)
frmXray.btnEditPacOrUwp.oncommand = function(id,event){
    if(frmXray.radioProxy.checked && _WIN10_LATER ){
        if(_STUDIO_INVOKED){
        	frmXray.msgErr("请先发布为 EXE！");
        	return;
        }
        
        import process;
    	process.execute(io._exepath,"/uwp","runas")
    	return;
    }
    
	if(frmPac && win.isWindow(frmPac.hwnd)){
		if( win.isIconic(frmPac.hwnd) ) win.show(frmPac.hwnd,9/*_SW_RESTORE*/ );
		if( !win.isVisible(frmPac.hwnd) ) win.show(frmPac.hwnd,0x1/*_SW_NORMAL*/ );
		win.setForeground(frmPac.hwnd)
		return;
	}

	frmPac = ..mainForm.loadForm("\forms\main\pac.aardio");
	frmPac.show();
}
subscribe("uiCommand.showPacForm",function(...){
	frmXray.btnEditPacOrUwp.oncommand();
} )

//消息窗口输出函数
subscribe("uiCommand.print",function(...){
	frmXray.edit.print(...);
} )

import xray.outbounds;
//定义“批量导入服务器”按钮功能
frmXray.btnImportServerFromClipBd.skin(style.plainButton)
frmXray.btnImportServerFromClipBd.oncommand = function(id,event){
	var str = ..win.clip.read();
	
			//debug.log.print(str)
	
	if(str){  
		str = ..string.trim(str,'"\'\t\r\n '); 
		
				//debug.log.print(str)
		
		if( ..string.startWith(str,"http://") 		//如果是链接，调用更新订阅程序，然后返回
			|| ..string.startWith(str,"https://") 
			|| ..string.match(str,"^\s*/\N+\s*$") ){
			if(..string.match(str,"^\s*/\N+\s*$")){
				str = "https://github.com" + str;
			}
			
					//debug.log.print(str)
			
			xray.outbounds.updateSubscription({[str]=true});
			return;
		}

		var outbounds = xray.outbounds.importFromString(str);		//不是链接调用importFromString函数导入数据
		if(#outbounds){
			..table.append(config.proxy.outbounds,outbounds);
			// 防止首次粘贴时，下载core失败导致没有保存节点的情况，所以手动save一下
			config.proxy.save();
			frmXray.msgOk("已成功导入" + #outbounds + "个服务器",1200); 
			publish("uiCommand.restartxrayCore");
			publish("outbounds.updateConfigJson");
			return; 
		}
	}

	frmXray.msgFrown('未导入服务器！\r\n请先复制以下格式文本（自动清除其中的无效内容）：\r\n\r\n1、一行或多行（忽略无效行）分享链接或服务器JSON配置。\r\n支持 vmess://，vless://，ss://，ssr://，trojan://， trojan-go:// 等通用分享链接。\r\n\r\n2、包含多个服务器配置的JSON数组,支持WinXray格式以及通用格式JSON。\r\n\r\n3、单个 http:// 或 https:// 开头的通用订阅源地址。\r\n可直接使用浏览器地址栏的github文件地址（含blob或raw目录名）。\r\n也可以仅复制单斜杆开始的github文件路径。\r\n\r\n订阅源可用BASE64编码或明文返回以上1、2条规定的配置或分享链接。')
}

//定时检测函数
frmXray.AutoTest = function(id,event){
	import console;
	import debug;
	import debug.log;	
	//console.dump(testTimerId);
	//debug.log.print("定时器被调用：",testTimerId);
	//debug.debug();
	
	autoTestTime = config.proxy.testInterval;
/*
	if(autoTestTime != config.proxy.testInterval && testTimerId ){
		frmXray.clearInterval(testTimerId);	//删除定时器
		autoTestTime = config.proxy.testInterval;
	}
*/

	import inet.http;
	//设置异常检查定时器,定时检测代理是否正常
	testTimerId = frmXray.setInterval( 
			autoTestTime*1000,function(){
				import debug

				if(!(currentOutboundIndex && currentOutboundAddress)) return ; 

				testOutbound(currentOutboundIndex,currentOutboundAddress,frmXray.chkAutoTest.checked,true);//定时检测代理状态
				
				if(autoTestTime != config.proxy.testInterval ){
					frmXray.clearInterval(testTimerId);	//删除定时器				
					frmXray.AutoTest ();
				}
		} 
	)
}
frmXray.AutoTest ();

//“异常自动重接”响应函数

/**
frmXray.chkAutoTest.oncommand = function(id,event){
	import console;
	import debug;
	import debug.log;	
	//console.dump(testTimerId);
	//debug.log.print("定时器为：",testTimerId);
	//debug.debug();
	config.proxy.AutoTest = frmXray.chkAutoTest.checked;//读取“异常自动重接”勾选状态
	return ; 
	
	if(testTimerId){
		frmXray.clearInterval(testTimerId);	//删除定时器
	}

	
	if(!config.proxy.AutoTest) {
		//frmXray.chkSearchMode.checked=false;
		
		//return;//“异常自动重接”未选就退出
	}

	import inet.http;
	//设置异常检查定时器,定时检测代理是否正常
	testTimerId = frmXray.setInterval( 
			config.proxy.testInterval*1000,function(){
				import debug
				//debug.log.print("timerTesting")
				//debug.debug();
				
			if(frmXray.btnTcping.disabled) return;//正在寻找服务器就返回
			if( frmXray.autoTesting ) return; //如果是自动测试就退出

			/*
var idx = frmXray.listview.activeOutboundIndex;
			var address = frmXray.listview.activeOutboundAddress;
			if( !( idx&&address) ){ //如果没有活动服务器就运行
				if(!inet.http.isAlive(,false)){
					return config.proxy.testInterval*1000;
				}
				
				if(!xray.core.lastDownloadingCoreFailed) {					
						frmXray.onStartXrayFailed(currentOutboundIndex,currentOutboundAddress,true);				
				}
				return; 
			}
			
			frmXray.autoTesting = true; 
*/			
			
			if( frmXray.chkAutoTest.checked) {		
				
				//var idx = frmXray.listview.activeOutboundIndex;
				//var address = frmXray.listview.activeOutboundAddress;
				var idx = currentOutboundIndex;
				var address = currentOutboundAddress;

					//debug.log.print("定时器运行：idx:",idx,",address:",address)
					//debug.log.print("定时器运行：currentOutboundIndex:"+currentOutboundIndex,",currentOutboundAddress:"+currentOutboundAddress)
				if( !( idx&&address) ){ //如果没有活动服务器就运行
					if(!inet.http.isAlive(,false)){
						return config.proxy.testInterval*1000;
					}
					
					if(!xray.core.lastDownloadingCoreFailed) {					
							frmXray.onStartXrayFailed(currentOutboundIndex,currentOutboundAddress,true);				
					}
					return; 
				}
				
					frmXray.autoTesting = true; 
					//isManualSwitch = false;
					activeOutbound(idx,address,true,true);//定时检测代理状态
			}
			elseif(currentOutboundIndex&&currentOutboundAddress) {
				
				activeOutbound(currentOutboundIndex,currentOutboundAddress,false,true);//定时检测代理状态
			}
			
			
			
			return config.proxy.testInterval*1000;
		} 
	)
}
**/

//搜索模式
/**
frmXray.chkSearchMode.oncommand = function(id,event){
	config.proxy.searchMode = frmXray.chkSearchMode.checked;
	
	//isManualSwitch = true;
	if(frmXray.chkSearchMode.checked) {
		//isOnSearching = true;
		frmXray.chkJustValid.checked = false;
		config.proxy.chkJustValid=false;
		frmXray.chkValidNoSearch.checked=true;
		frmXray.chkAutoTest.checked=true
		isManualSwitch = false;
		/*
if(testTimerId){
			frmXray.clearInterval(testTimerId);	//删除定时器
		}	
*/
		//debug.debug();
		frmXray.btnTcping.text="点击开始搜索";
		//debug.log.print("手动切换服务器,currentOutboundIndex为:"+currentOutboundIndex);
		frmXray.edit.print("开始搜索模式"); 
		
		
		//frmXray.onStartXrayFailed(currentOutboundIndex,currentOutboundAddress,true);
	}
	else {
		isOnSearching = false;
		frmXray.btnTcping.text="检测并连接最快服务器";
	  frmXray.edit.print("退出搜索模式")
	  }
	import debug.log
	import console
	//console.dumpTable(frmXray.chkSearchMode.checked)
}
**/
//debug.log.print("config.proxy.searcherIndex:"+config.proxy.searcherIndex);
//debug.debug();
var searcherTimerID; 
frmXray.searcherIndex =config.proxy.searcherIndex ? config.proxy.searcherIndex : 1;
//frmXray.searcherIndex = 1;
setSearcherTimer = function(){
	if(searcherTimerID) frmXray.clearInterval(searcherTimerID);
	searcherTimerID = frmXray.setInterval( 
				5000,function(){
					//import config;
					//config.proxy.save();
					frmXray.chkSearchMode.oncommand();		
					
				} 
			)
}
frmXray.onSearcherSucces = function(outboundIndex,outbound,success){
	//debug.log.print(outboundIndex)
	var outbounds = config.proxy.outbounds;
	if(outbounds[outboundIndex].address == outbound.address ){
		if( success ){//连通，发布“连接成功”消息
		
						//console.print("outbound为：");
						//console.dump(outbound.address);
						//frmXray.edit.print("找到可用服务器，索引号为："+outboundIndex+",服务器地址为："+outbound.address);
			//debug.log.print("后台搜索活动检测器：回复为：",lastStatusCode,"timerTesting为：",timerTesting);

			//frmXray.edit.print("找到可用服务器，索引号为："+outboundIndex+",服务器地址为："+outbound.address);
							//outbound.ps = "已测通";
							//outbound.lastValiable=tostring(time.now());
			outbounds[outboundIndex].lastValiable=tostring(time.now());
			outbounds[outboundIndex].ps = "已测通";
							//..config.proxy.outbounds[outboundIndex].lastValiable=tostring(time.now());
							//outbounds[outboundIndex].ps = "已测通";							
							//outbounds[outboundIndex].failedCount = 0;//重置失败计数器
			frmXray.listview.setItemText("已测通",outboundIndex,6);
			//console.print("act:outbound.lastValiable:"+outbounds[outboundIndex].lastValiable)
							//console.print("act:outbounds[outboundIndex].lastValiable:"+outbounds[outboundIndex].lastValiable)
							//frmXray.listview.setItemText("上次可用："+outbounds[outboundIndex].lastValiable,outboundIndex,8);
							//break;
							//frmXray.listview.ensureVisible(outboundIndex);//确保此行可见
						
						//frmXray.onStartXrayComplete(outboundIndex,outboundAddress,timerTesting); 
						//frmXray.isOnActive=0;
						//debug.debug();
						////return;	
		}
		else {
			if(!outbounds[outboundIndex].failedCount){
				outbounds[outboundIndex].failedCount = 1;
			}
			else {
				outbounds[outboundIndex].failedCount++;
			}
		}	 
		if(outbounds[outboundIndex].lastValiable) {
			frmXray.listview.setItemText("上次可用："+outbounds[outboundIndex].lastValiable,outboundIndex,8);
		}
		elseif(outbounds[outboundIndex].failedCount){
			frmXray.listview.setItemText("失败次数："+outbounds[outboundIndex].failedCount,outboundIndex,8);
		}
		
		
	}
	else {
		return false;  
	}
	
	
}
frmXray.chkSearchMode.oncommand = function(id,event){
	//import config
	config.proxy.searchMode = frmXray.chkSearchMode.checked;
	config.proxy.searcherIndex = frmXray.searcherIndex ;
	//config.proxy.save();
	
	//isManualSwitch = true;
	if(frmXray.chkSearchMode.checked) {	//勾选才后台搜索，否则设定定时器间隔运行
		if(frmXray.searchingBackground ) {
		//debug.log.print("searchingBackground is true,return.");
			return ;
		}
		if(!xray.core.prcsxray ) {
			debug.log.print("xray.core.prcsxray is null.")
			
			//setSearcherTimer();
			return ;
		}
		if(searcherTimerID) frmXray.clearInterval(searcherTimerID);
		frmXray.searchingBackground = true; 
		var outbounds = config.proxy.outbounds ; 
		
		if(frmXray.searcherIndex > #outbounds) frmXray.searcherIndex = 1;
		var next = outbounds[frmXray.searcherIndex]; 
		//debug.debug();
		if(next.protocol == "ssr" || next.protocol == "naive"){
			//switchOutbound(frmXray.searcherIndex,next.address);
			frmXray.searcherIndex ++;
			frmXray.searchingBackground = false;
			frmXray.chkSearchMode.oncommand();
			return ; 
		}
		frmXray.edit.print("后台搜索序号: "+frmXray.searcherIndex+" ,地址为："+next.address+"总数为："+#outbounds) ;
		
		frmXray.listview.setItemText("后台测试中",frmXray.searcherIndex,8);	
		frmXray.listview.ensureVisible(frmXray.searcherIndex);//确保此行可见		
		
		//先清除xray搜索服务器配置，然后再添加新的
		var cleaner;
		var i = 1;			
		while(!cleaner && i<4 ){
			//console.print("删除配置回复null")	
			//cleaner = xray.core.stopSearcher(frmXray.edit,outbound);
			i++;
			cleaner = xray.core.deleteOutbound(frmXray.edit,outbound,"proxySearcher","searcherConfig.json");
		}
		//console.print("删除配置回复："+cleaner)	
		//frmXray.searcherIndex = 1;
		
		//console.print("next.lastValiable:"+next.lastValiable)
		var adder//xray添加搜索配置		
		while(!adder && i>1 ){
			//console.print("添加配置回复null")
			//adder = xray.core.startSearcher(frmXray.edit,next);
			i--;
			adder = xray.core.addOutbound(frmXray,frmXray.edit,next,"proxySearcher","searcherConfig.json");
		}
		//console.print("添加配置回复："+adder);
		
/*
		
		//for(p=frmXray.searcherIndex;#outbounds;1){
			next = outbounds[frmXray.searcherIndex]; 
			
			console.print("选择前next地址为：")	
			console.dump(next.address);		
			
			if(next.failedCount){							
			for( i=frmXray.searcherIndex+1;#outbounds;1 ){   					 
				var j =outbounds[i];
				if(outbounds[i].ps == "已测通"){
					continue;	
				}		
				if(!outbounds[i].failedCount) {//找出最近可用的服务器,没有记录的失败计数视为0
					next=j;
					break;
				}
				elseif(next.failedCount > j.failedCount){
					next=j;
				}						
			}
			if(next.failedCount){
				debug.log.print("后台搜索failedCount为"+next.failedCount+"当前服务器为："+next.address);
			}
			else {
				debug.log.print("后台搜索failedCount为0或NULL");
			}
				
			}	
*/
			
			//console.print("选择后next地址为：")	
			//console.dump(next.address);
			
			
			import xray.core
			..thread.invoke( //新建测试线程
				function(frmXray,outbound,outboundIndex,outbounds,searcherHttpProxyPort,enableRetry,timerTesting){
				import debug
				import debug.log
				//import config		
				//var outbounds = ..config.proxy.outbounds ; 
				//debug.log.print(#outbounds,outboundIndex);
				//console.print("前outboundIndex:"+outboundIndex)
				//console.print("前outbound.lastValiable:"+outbound.lastValiable)
				//console.print("前outbounds[outboundIndex].lastValiable:"+outbounds[outboundIndex].lastValiable)
				import web.rest.client;
				/*
if(outbound.protocol == "ssr" || outbound.protocol == "naive" ){
					console.dump(frmXray.searcherIndex);
					frmXray.searcherIndex ++;
					frmXray.chkSearchMode.oncommand();
					return ; 
				}
*/
				//debug.log.print("httpProxyAddress为："+httpProxyAddress);
				for(i=1;1;1){		
/*
					debug.log.print(searcherHttpProxyPort)	
							
					test = "127.0.0.1:"+searcherHttpProxyPort
					debug.log.print(test)
*/
					var restClient = web.rest.client(,"127.0.0.1:"+searcherHttpProxyPort);
					
					//console.print("127.0.0.1:"+..xray.core.searcherHttpProxyPort)
					restClient._http.setTimeouts(4000,5000,5000);
					//timeTick = time.tick(); 
					var ret = restClient.get("https://www.google.com/generate_204");
				
					
					var lastStatusCode = restClient.lastStatusCode;
					
					//debug.log.print("后台搜索活动检测器：回复为：",lastStatusCode,"timerTesting为：",timerTesting);
					if( lastStatusCode == 204 ){//连通，发布“连接成功”消息
						
						//console.print("outbound为：");
						//console.dump(outbound.address);
						frmXray.edit.print("找到可用服务器，索引号为："+outboundIndex+",服务器地址为："+outbound.address);
						//debug.log.print("后台搜索活动检测器：回复为：",lastStatusCode,"timerTesting为：",timerTesting);
/*
						if(outbounds[outboundIndex].address == outbound.address ){
							outbound.ps = "已测通";
							outbound.lastValiable=tostring(time.now());
							outbounds[outboundIndex].lastValiable=tostring(time.now());
							..config.proxy.outbounds[outboundIndex].lastValiable=tostring(time.now());
							//outbounds[outboundIndex].ps = "已测通";							
							//outbounds[outboundIndex].failedCount = 0;//重置失败计数器
							frmXray.listview.setItemText("已测通",outboundIndex,6);
							console.print("act:outbound.lastValiable:"+outbound.lastValiable)
							console.print("act:outbounds[outboundIndex].lastValiable:"+outbounds[outboundIndex].lastValiable)
							//frmXray.listview.setItemText("上次可用："+outbounds[outboundIndex].lastValiable,outboundIndex,8);
							break;
							//frmXray.listview.ensureVisible(outboundIndex);//确保此行可见
						}
*/
						//frmXray.onStartXrayComplete(outboundIndex,outboundAddress,timerTesting); 
						//frmXray.isOnActive=0;
						//debug.debug();
						////return;	
						frmXray.onSearcherSucces(outboundIndex,outbound,true);
						break;
					}
					else {
						frmXray.onSearcherSucces(outboundIndex,outbound,false);
						 
					}
					
					restClient.close();
				}
				
				frmXray.searcherIndex++ ;
				frmXray.searchingBackground = false;
				frmXray.chkSearchMode.oncommand();

			},frmXray,next,frmXray.searcherIndex,outbounds,xray.core.searcherHttpProxyPort
			)
			//frmXray.searcherIndex = p;
			
		//}

	}
	else {
		if(searcherTimerID) frmXray.clearInterval(searcherTimerID);
		searchingBackground = false;
		frmXray.edit.print("退出搜索模式")
	  }
	import debug.log
	import console
	
	

	//console.dumpTable(frmXray.chkSearchMode.checked)
}
//已测通不参加搜索 响应函数
//debug.log.print("")
frmXray.chkValidNoSearch.oncommand = function(id,event){
	 config.proxy.chkValidNoSearch=frmXray.chkValidNoSearch.checked;
/*
	if(frmXray.chkValidNoSearch.checked){ 
		frmXray.chkJustValid.checked=false;
		config.proxy.chkJustValid = false;
	}
*/
}

//仅已测通
frmXray.chkJustValid.oncommand = function(id,event){
	config.proxy.chkJustValid=frmXray.chkJustValid.checked;
	if(frmXray.chkJustValid.checked) {
		//frmXray.chkValidNoSearch.checked=false;
		frmXray.chkSearchMode.checked = false;
		//frmXray.chkSearchMode.oncommand();
		//isManualSwitch = false;
	}
	
}



//流量使用统计函数

frmXray.trafficStats = function(){
	import debug
	//debug.log.print("流量状态函数启动")
	if(isOnSearching) return ; 
	if(trafficTimerId){ frmXray.clearInterval(trafficTimerId); }
	//var apiTime = config.settings.apiTime;
	apiTime = 2000;//更新时间间隔
	
	var downValue,upValue;
	//try{		
			upSpeed = config.proxy.outbounds[currentOutboundIndex].upSpeed;			
	/*
	}
		catch(e){
*/
			//debug.log.print("upSpeed为",upSpeed);
			if(!upSpeed) upSpeed = 0;
		//}
			//frmXray.listview.setItemText(math.size64(upSpeed).format(),activeIndex,11);			
		//try{	
			downSpeed = config.proxy.outbounds[currentOutboundIndex].downSpeed;			
			//frmXray.listview.setItemText(math.size64(downSpeed).format(),activeIndex,12);	
	/*
	}
		catch(e){
*/
			//debug.log.print("downSpeed为",downSpeed);	
			if(!downSpeed) downSpeed = 0;		
			//frmXray.listview.setItemText(math.size64(downSpeed).format(),activeIndex,12);	
		//}
/*
	catch(e){
		upSpeed = 0;
		//frmXray.listview.setItemText(math.size64(upSpeed).format(),activeIndex,11);			
		downSpeed = 0;
		//frmXray.listview.setItemText(math.size64(downSpeed).format(),activeIndex,12);	
	}
*/
	//debug.log.print("upSpeed为",upSpeed,"，downSpeed为",downSpeed);
	
	//var  ? ..config.proxy.outbounds[activeIndex].upSpeed : 0;
	//var 
/*
	
	
*/
	
	trafficTimerId = frmXray.setInterval( 
		function(){

			import debug
			import debug.log
			//debug.log.print("流量状态定时器触发")
			if(isOnSearching) return ; 
			//var activeIndex = frmXray.listview.activeOutboundIndex;
			if( !currentOutboundIndex ){ return apiTime }
			
			import TrafficStats;

			downValue,upValue = TrafficStats.start();

			if(downValue){
				var downTraffic = config.proxy.outbounds[currentOutboundIndex].trafficDown;
				if( downTraffic ){ downTraffic += downValue}
				else {downTraffic = downValue}
				
				config.proxy.outbounds[currentOutboundIndex].trafficDown = downTraffic;
				config.proxy.outbounds[currentOutboundIndex].downText = math.size64(downTraffic).format();
				//config.proxy.save();
				frmXray.listview.setItemText(math.size64(downTraffic).format(),currentOutboundIndex,10);
				
				//if(downSpeed){
					if(downSpeed<downValue/2) {
						downSpeed= downValue/2;
						config.proxy.outbounds[currentOutboundIndex].downSpeed = downSpeed;
						frmXray.listview.setItemText(math.size64(downSpeed).format(),currentOutboundIndex,12);
					}
				//}
				//else downSpeed = config.proxy.outbounds[activeIndex].downSpeed;
			if(upValue){//有下行流量上行流量才有意义
				var upTraffic = config.proxy.outbounds[currentOutboundIndex].trafficUp;
				if( upTraffic ){ upTraffic += upValue}
				else {upTraffic = upValue}				
				config.proxy.outbounds[currentOutboundIndex].trafficUp = upTraffic;				
				//config.proxy.outbounds[currentOutboundIndex].upText = math.size64(upTraffic).format();
				//config.proxy.save();
				//io.print("上行流量："+upValue+"下行流量："+downValue);
				//debug.log.print("上行流量："+upTraffic+"下行流量："+downValue);
				frmXray.listview.setItemText(math.size64(upTraffic).format(),currentOutboundIndex,9);
				
				//if(upSpeed){
					//debug.log.print("定时器：upSpeed为",upSpeed,",upValue为",upValue);	
					if(upSpeed<upValue/2) {
						upSpeed= upValue/2;
						config.proxy.outbounds[currentOutboundIndex].upSpeed = upSpeed;
						frmXray.listview.setItemText(math.size64(upSpeed).format(),currentOutboundIndex,11);
					}
				//}
				//else upSpeed = config.proxy.outbounds[activeIndex].upSpeed;
			}	
			}
			
		},apiTime 
	)
}
//订阅流量使用统计
subscribe("uiCommand.traffic",function(start){
    //var api = ..config.core.default[["api"]];
    var api = 2000;
/*
	if(!api || !api.tag || !(api.tag=="api")){
		frmXray.msgFrown('你的内核配置有误，无法开启流量统计\n请在"配置"页面重置为默认内核配置！');
		return;
	}
*/
	//if(start && config.settings.apiTime!=-1){
	if(start){
		//debug.log.print("收到流量监控启动消息");
		frmXray.trafficStats();
	}
	else {
		if(trafficTimerId){
			frmXray.clearInterval(trafficTimerId);
		}
	}	
} )



//日志窗口启用右键弹出菜单
frmXray.edit.enablePopMenu({
	{ /*---分隔线---*/ };
	{ "清屏";
		function(){
			var text = frmXray.edit.text;
			if(#text){
				frmXray.edit.text='';
			}
		}
	}; 
})





frmXray.enableDpiScaling();
win.loopMessage();

/**intellisense
tcping( = 代理节点延迟测试
tcping(.(编辑器 ,代理节点索引 ,代理节点) = 
end intellisense**/